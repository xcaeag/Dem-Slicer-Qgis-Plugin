# -*- coding: utf-8 -*-
"""
/***************************************************************************
 DemSlicerDockWidget
                                 A QGIS plugin
 D.E.M. slicer, produces lines
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2019-10-24
        git sha              : $Format:%H$
        copyright            : (C) 2019 by xc
        email                : xavier.culos@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from qgis.PyQt import QtWidgets, uic
from qgis.PyQt.QtWidgets import QFileDialog
from qgis.PyQt.QtCore import QCoreApplication, QTranslator, pyqtSignal, Qt, QVariant, QSettings
from qgis.PyQt.QtGui import QColor
from qgis.core import Qgis, QgsWkbTypes, QgsGeometry, QgsPointXY, QgsMessageLog, QgsProject, QgsMapLayer, QgsVectorLayer, QgsField
from qgis.core import QgsFeature, QgsRaster, QgsCoordinateTransform, QgsFeatureRequest, QgsRectangle
from qgis.gui import QgsRubberBand, QgsMapTool
import math
import sys
import traceback

FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'dem_slicer_dockwidget_base.ui'))


class DemSlicerDockWidget(QtWidgets.QDockWidget, FORM_CLASS):

    closingPlugin = pyqtSignal()
    plugin = None

    def __init__(self, _plugin, parent=None):
        """Constructor."""
        super(DemSlicerDockWidget, self).__init__(parent)
        self.setupUi(self)
        self.plugin = _plugin
        self.canvas = self.plugin.iface.mapCanvas()
        self.started = False
        self.btnStart.setCheckable(True)
        self.mt = MapTool(self)
        self.plugin_dir = os.path.dirname(__file__)

        locale = QSettings().value("locale/userLocale")[0:2]
        localePath = os.path.join(self.plugin_dir, 'i18n', '{}.qm'.format(locale))
        self.info(localePath)

        if os.path.exists(localePath):
            self.translator = QTranslator()
            self.translator.load(localePath)
            QCoreApplication.installTranslator(self.translator)

        for widget in [self.rasterListLabel, self.btnBuild, self.btnStart, self.lineCountLabel, self.zFactorLabel, self.xStepLabel, self.zShiftLabel, self.renderLines, self.renderPolygons, self.renderRidges, self.parallelView, self.poiListLabel, self.labelElevation, self.btnLoad]:
            widget.setText(self.tr(widget.text()))

        for widget in [self.btnSave, self.reset, self.btnLoad]:
            widget.setToolTip(self.tr(widget.toolTip()))

        self.widget2Enable = [self.lineCount, self.rasterList, self.poiList, self.xStep, self.zShift, self.zFactor, self.renderLines, self.renderPolygons, self.renderRidges,
                              self.btnBuild, self.progressBar, self.parallelView, self.reset, self.btnLoad, self.btnSave, self.elevation]

        self.alert.setText('')

    def tr(self, message):
        return QCoreApplication.translate('DemSlicer', message)

    def closeEvent(self, event):
        self.closingPlugin.emit()
        event.accept()

    def info(self, message, d=1):
        self.plugin.iface.messageBar().pushMessage("DEM Slicer", self.tr(message), level=Qgis.Info, duration=d)

    def log(self, message):
        QgsMessageLog.logMessage(message, 'Extensions')

    def start(self):
        """Start the processus : activates tools, builds rubber bands...
        """
        self.info("Start")

        rId = self.rasterList.itemData(self.rasterList.currentIndex())
        poiId = self.poiList.itemData(self.poiList.currentIndex())
        self.rasterList.clear()
        self.poiList.clear()
        self.poiList.addItem('- None -', 0)
        i, j = 0, 1
        for layer in QgsProject.instance().mapLayers().values():
            # If layer is a raster and it is not a multiband type
            if layer.type() == QgsMapLayer.RasterLayer:  # and layer.renderer().type() != "multibandcolor":
                # Add to list
                self.rasterList.addItem(layer.name(), layer.id())
                if layer.id() == rId:
                    self.rasterList.setCurrentIndex(i)
                i = i+1

            if layer.type() == QgsMapLayer.VectorLayer:  # and (layer.geometryType() == QgsWkbTypes.PointGeometry or layer.geometryType() == QgsWkbTypes.MultiPoint):
                # Add to list
                self.poiList.addItem(layer.name(), layer.id())
                if layer.id() == poiId:
                    self.poiList.setCurrentIndex(j)
                j = j+1

        if i == 0:
            return False

        for w in self.widget2Enable:
            w.setEnabled(True)

        self.canvas.setMapTool(self.mt)

        self.mt.newRubber()

        return True

    def cancel(self):
        # self.info("Cancel")
        self.mt.hide()
        self.canvas.unsetMapTool(self.mt)

        for w in self.widget2Enable:
            w.setEnabled(False)

    def getElevation(self, point):
        """
        :param point: The point to identify elevation (mntLayer crs)
        :type point: QgsPointXY

        :return: The elevation (first band value)
        :rtype: int
         """
        try:
            v = self.mntLayer.dataProvider().identify(point, QgsRaster.IdentifyFormatValue).results().values()
            return int(list(v)[0])
            # v, ok = self.mntLayer.dataProvider().sample(point, 0)
            # return v if ok else 0
        except:
            return 0

    def getGaz(self, pt1, pt2, polys, prof):
        pt = QgsPointXY((pt1.x()+pt2.x())/2, (pt1.y()+pt2.y())/2)

        for i, p in enumerate(polys[::-1]):
            if i > prof and p.contains(pt):
                return i-prof

        return None

    def getVisibility(self, pt, polys, prof):
        visi = 1
        for i, p in enumerate(polys[::-1]):
            if prof > i and p.contains(pt):
                visi = visi-1

            if visi <= -10:
                break

        return visi

    def getZShift(self, depth):
        """
            depth : distance (en profondeur) entre la première ligne visée et le point (xy - à plat)
        """
        z = self.elevation.value()
        dd = self.mt.zoneDepth / (self.lineCount.value()-1)
        dist = self.mt.d0 + depth
        ixL = round(depth / dd)
        # alpha = math.atan(z/dist)
        dh = depth * (z/dist)  # math.tan(alpha)
        return dh + ixL*self.zShift.value(), ixL  # profondeur

    def addDetail(self, polyline, dx):
        if self.xStep.value() < dx:
            for line in polyline:
                p0, p1 = line[0], line[1]
                p0p1 = p0.distance(p1)
                x = p1.x()-p0.x()
                y = p1.y()-p0.y()
                if self.xStep.value() < p0p1:
                    p = QgsPointXY(p0.x()+x*self.xStep.value()/p0p1, p0.y()+y*self.xStep.value()/p0p1)
                    line.insert(1, p)
                if 2*self.xStep.value() < dx and 2*self.xStep.value() < p0p1:
                    p = QgsPointXY(p0.x()+2*x*self.xStep.value()/p0p1, p0.y()+2*y*self.xStep.value()/p0p1)
                    line.insert(2, p)

    def getThumbnailGeom(self):
        # emprise initiale ... lignes
        # limiter le nombre de colonnes, lignes à une dizaine
        dx = self.mt.finalWidth / 10
        lines = self.mt.getSampleLines()
        geom = QgsGeometry.fromMultiPolylineXY(lines)
        lineCount = len(lines)
        if self.parallelView.isChecked():
            polylineIn = geom.densifyByDistance(dx).asMultiPolyline()
            self.addDetail(polylineIn, dx)
        else:
            aH = self.mt.pY.azimuth(self.mt.pH)
            aD = self.mt.pY.azimuth(self.mt.pD)
            if aD > aH:
                aH = aH + 360

            alpha = aH-aD
            dAlphaDetail = 2 * alpha / (self.mt.finalWidth / self.xStep.value())
            dAlpha = 2 * alpha / (self.mt.finalWidth / dx)

            aPrim = QgsGeometry.fromPointXY(self.mt.pH)
            aPrim.rotate(-alpha, self.mt.pY)
            aPrim = aPrim.asPoint()
            dPrim = QgsGeometry.fromPointXY(self.mt.pM)
            dPrim.rotate(-alpha, self.mt.pY)
            dPrim = dPrim.asPoint()

            gauche = QgsGeometry.fromPolylineXY([aPrim, dPrim]).densifyByCount(lineCount-2).asPolyline()
            polyline = []
            for p in gauche:
                line = []

                # premier point
                g = QgsGeometry.fromPointXY(p)
                line.append(g.asPoint())

                # deuxième
                g = QgsGeometry.fromPointXY(p)
                g.rotate(dAlphaDetail, self.mt.pY)
                line.append(g.asPoint())

                # troisième
                g = QgsGeometry.fromPointXY(p)
                g.rotate(2*dAlphaDetail, self.mt.pY)
                line.append(g.asPoint())

                for nx in range(2+int(self.mt.finalWidth / dx)):
                    if nx*dAlpha > 2*dAlphaDetail:
                        g = QgsGeometry.fromPointXY(p)
                        g.rotate(nx*dAlpha, self.mt.pY)
                        line.append(g.asPoint())

                polyline.append(line)

            polylineIn = polyline

        lines = self.mt.getSampleSkylines()
        geom = QgsGeometry.fromMultiPolylineXY(lines)
        polylineOut = geom.densifyByDistance(dx).asMultiPolyline()
        self.addDetail(polylineOut, dx)
        xmin = geom.boundingBox().xMinimum()
        xmax = geom.boundingBox().xMaximum()
        ymin = geom.boundingBox().yMinimum()

        # search for Z values
        aPolys = []
        for lineIn, lineOut in zip(polylineIn, polylineOut):
            xs, ys, zs = map(list, zip(*[(point.x(), point.y(), self.getElevation(self.xMap2Raster.transform(point.x(), point.y()))-self.altY) for point in lineIn]))

            zf = self.zFactor.value()
            for z, point in zip(zs, lineOut):
                point.setY(point.y() + z*zf)

            lineOut.append(QgsPointXY(xmax, ymin-2*self.zShift.value()-self.altY))
            lineOut.append(QgsPointXY(xmin, ymin-2*self.zShift.value()-self.altY))
            aPolys.append([lineOut])

        return QgsGeometry.fromMultiPolygonXY(aPolys)

    def buildSlices(self):

        def projPolyline(polyline):
            segAD = QgsGeometry.fromPolylineXY([self.mt.pA, self.mt.pD])
            segCD = QgsGeometry.fromPolylineXY([self.mt.pC, self.mt.pD])
            prof1 = 0
            for i, pt in enumerate(polyline):
                z = (self.getElevation(self.xMap2Raster.transform(pt.x(), pt.y()))-self.altY)*self.zFactor.value()
                if self.parallelView.isChecked():
                    # self.info("//")
                    newX = self.mt.pR.x()+segAD.distance(QgsGeometry.fromPointXY(pt))
                    zs, prof = self.getZShift(segCD.distance(QgsGeometry.fromPointXY(pt)))
                else:
                    d = self.mt.pY.distance(pt)
                    az = self.mt.pY.azimuth(pt)

                    if aD > az:
                        az = az + 360
                    fx = (az-aD)/angleVue
                    newX = self.mt.pR.x() + fx*self.mt.finalWidth
                    zs, prof = self.getZShift(d-self.mt.d0)

                newY = self.mt.pR.y() + zs + z

                if i == 1:
                    prof1 = prof

                polyline[i].setX(newX)
                polyline[i].setY(newY)

            return prof1

        def projLineString(feat, polyline):
            # reprojeter les points
            prof1 = projPolyline(polyline)

            if len(polyline) > 1:
                visi = self.getVisibility(polyline[1], aPolys, prof1)
                fet0 = QgsFeature(fid)
                fet0.setAttributes(feat.attributes()+[str(fid), visi, prof1])
                fet0.setGeometry(QgsGeometry.fromPolylineXY(polyline))
                return fet0
            else:
                return None

        def projPolygon(feat, polygon):
            # reprojeter les points
            prof1 = 0
            self.log("in projPolyline, altY = {}".format(self.altY))
            for polyline in polygon:
                prof1 = projPolyline(polyline)

            try:
                visi = self.getVisibility(polygon[0][1], aPolys, prof1)
                fet0 = QgsFeature(fid)
                fet0.setAttributes(feat.attributes()+[str(fid), visi, prof1])
                fet0.setGeometry(QgsGeometry.fromPolygonXY(polygon))
                return fet0
            except:
                return None

        # emprise initiale ... lignes
        dx = self.xStep.value()
        geom = self.mt.getLines()
        if self.parallelView.isChecked():
            polylineIn = geom.densifyByDistance(dx).asMultiPolyline()
        else:
            aH = self.mt.pY.azimuth(self.mt.pH)
            aD = self.mt.pY.azimuth(self.mt.pD)
            if aD > aH:
                aH = aH + 360

            alpha = aH-aD
            dAlpha = 2 * alpha / (self.mt.finalWidth / dx)
            # self.log("{} {} {}".format(str(aH), str(aD), str(dAlpha)))
            # dAlpha = dAlpha if dAlpha > 0 else -dAlpha

            aPrim = QgsGeometry.fromPointXY(self.mt.pH)
            aPrim.rotate(-alpha, self.mt.pY)
            aPrim = aPrim.asPoint()
            dPrim = QgsGeometry.fromPointXY(self.mt.pM)
            dPrim.rotate(-alpha, self.mt.pY)
            dPrim = dPrim.asPoint()

            gauche = QgsGeometry.fromPolylineXY([aPrim, dPrim]).densifyByCount(self.lineCount.value()-2).asPolyline()
            polyline = []
            for p in gauche:
                line = []
                for nx in range(2+int(self.mt.finalWidth / dx)):
                    g = QgsGeometry.fromPointXY(p)
                    g.rotate(nx*dAlpha, self.mt.pY)
                    line.append(g.asPoint())

                polyline.append(line)

            polylineIn = polyline

        geom = self.mt.getSkylines()
        polylineOut = geom.densifyByDistance(dx).asMultiPolyline()
        xmin = geom.boundingBox().xMinimum()
        xmax = geom.boundingBox().xMaximum()
        ymin = geom.boundingBox().yMinimum()

        # New points layer
        """if self.renderPoints.isChecked():
            ptLayer = QgsVectorLayer("MultiPoint?crs={}".format(QgsProject.instance().crs().authid()), "Points", "memory")
            QgsProject.instance().addMapLayer(ptLayer)
            ptLayer.startEditing()
            ptLayer.dataProvider().addAttributes([QgsField("num", QVariant.Int)])
            ptLayer.dataProvider().addAttributes([QgsField("z", QVariant.Int)])
            # +  x, y, azimuth
            ptLayer.updateFields()
        """

        fid = 1
        # search for Z values
        progess = 0
        self.progressBar.setMaximum(len(polylineIn) + (len(polylineIn) * self.renderLines.isChecked()) + (len(polylineIn) * self.renderPolygons.isChecked()) + (2*len(polylineIn) * self.renderRidges.isChecked()))
        aLines = []
        aPolys = []
        zf = self.zFactor.value()

        for lineIn, lineOut in zip(polylineIn, polylineOut):
            self.progressBar.setValue(progess)
            progess = progess + 1
            xs, ys, zs = map(list, zip(*[(point.x(), point.y(), self.getElevation(self.xMap2Raster.transform(point.x(), point.y()))-self.altY) for point in lineIn]))

            for z, point in zip(zs, lineOut):
                point.setY(point.y()+z*zf)

                """if self.renderPoints.isChecked():
                    pt = QgsGeometry.fromPointXY(point)
                    fet0 = QgsFeature(fid)
                    fet0.setAttributes([str(fid), z])
                    fet0.setGeometry(pt)
                    ptLayer.dataProvider().addFeatures([fet0])
                """

            aLines.append(QgsGeometry.fromPolylineXY(lineOut))
            fid = fid+1

            lineOut.append(QgsPointXY(xmax, ymin-2*self.zShift.value()-self.altY))
            lineOut.append(QgsPointXY(xmin, ymin-2*self.zShift.value()-self.altY))
            aPolys.append(QgsGeometry.fromPolygonXY([lineOut]))

        # Points --------------------------------------------------------------------
        """if self.renderPoints.isChecked():
            ptLayer.loadNamedStyle(self.plugin_dir + '/points.qml')
            ptLayer.commitChanges()
        """

        # Line Slices --------------------------------------------------------------------
        if self.renderLines.isChecked():
            layer = QgsVectorLayer("MultiLineString?crs={}".format(QgsProject.instance().crs().authid()), "Lines", "memory")
            QgsProject.instance().addMapLayer(layer)
            layer.startEditing()
            layer.dataProvider().addAttributes([QgsField("num", QVariant.Int)])
            # +  x1, y1, x2, y2
            layer.updateFields()
            feats = []
            for fid, lin in enumerate(aLines):
                self.progressBar.setValue(progess)
                progess = progess + 1
                feature = QgsFeature(fid)
                feature.setAttributes([str(fid)])
                feature.setGeometry(lin)
                feats.append(feature)

            layer.dataProvider().addFeatures(feats)

            layer.loadNamedStyle(self.plugin_dir + '/lines.qml')
            layer.commitChanges()

        # Poly Slices --------------------------------------------------------------------
        if self.renderPolygons.isChecked():
            pLayer = QgsVectorLayer("Polygon?crs={}".format(QgsProject.instance().crs().authid()), "Polygons", "memory")
            QgsProject.instance().addMapLayer(pLayer)
            pLayer.dataProvider().addAttributes([QgsField("num", QVariant.Int)])
            # +  x1, y1, x2, y2
            pLayer.startEditing()
            pLayer.updateFields()
            feats = []
            for fid, p in enumerate(aPolys):
                self.progressBar.setValue(progess)
                progess = progess + 1
                feature = QgsFeature(fid)
                feature.setAttributes([str(fid)])
                feature.setGeometry(p)
                feats.append(feature)

            pLayer.dataProvider().addFeatures(feats)

            if self.renderRidges.isChecked():
                pLayer.loadNamedStyle(self.plugin_dir + '/polygons_ridges.qml')
            else:
                pLayer.loadNamedStyle(self.plugin_dir + '/polygons.qml')
            pLayer.commitChanges()

        # RIDGES --------------------------------------------------------------------
        if self.renderRidges.isChecked():
            hLayer = QgsVectorLayer("LineString?crs={}".format(QgsProject.instance().crs().authid()), "Ridges", "memory")
            hLayer.loadNamedStyle(self.plugin_dir + '/ridges.qml')
            QgsProject.instance().addMapLayer(hLayer)
            hLayer.startEditing()
            hLayer.dataProvider().addAttributes([QgsField("num", QVariant.Int)])
            hLayer.dataProvider().addAttributes([QgsField("gaz", QVariant.Int)])
            hLayer.dataProvider().addAttributes([QgsField("prof", QVariant.Int)])
            # +  x1, y1, x2, y2
            hLayer.updateFields()

            horizons = []
            previousLine = None
            previousPolygon = None
            polyMax = None
            for lin, poly in zip(aLines[::-1], aPolys[::-1]):
                self.progressBar.setValue(progess)
                progess = progess + 1
                if previousLine is None:
                    previousLine = lin
                    previousPolygon = poly
                    continue

                # mask = QgsGeometry(poly)
                # mask.translate(5*random.random(), 5*random.random())
                # cut = previousLine.difference(mask)
                cut = previousLine.difference(poly)
                if polyMax is not None and not polyMax.isNull():
                    cut = cut.difference(polyMax)
                    polyMax = polyMax.combine(previousPolygon)
                else:
                    polyMax = previousPolygon

                horizons.append(cut)

                previousLine = lin
                previousPolygon = poly

            # dernière ligne
            cut = aLines[0].difference(aPolys[1])
            cut = cut.difference(polyMax)
            horizons.append(cut)

            fid = 1
            feats = []
            for prof, lin in enumerate(horizons):
                self.progressBar.setValue(progess)
                progess = progess + 1
                if lin.isMultipart():
                    # self.log("Ridge MULTI part")
                    try:
                        pp = lin.asMultiPolyline()
                        for polyline in pp:
                            if len(polyline) == 0:
                                continue
                            pt0 = polyline[0]
                            for pt in polyline[1:]:
                                seg = [pt0, pt]
                                feature = QgsFeature(fid)
                                feature.setAttributes([str(fid), self.getGaz(pt0, pt, aPolys, prof), prof])
                                feature.setGeometry(QgsGeometry.fromPolylineXY(seg))
                                feats.append(feature)
                                fid = fid+1
                                pt0 = pt
                    except:
                        exc_type, exc_value, exc_traceback = sys.exc_info()
                        format_exception = traceback.format_exception(exc_type, exc_value, exc_traceback)
                        """
                        self.log("--------- ERR in {} ---------------".format(prof))
                        self.log(repr(format_exception[0]))
                        self.log(repr(format_exception[1]))
                        self.log(repr(format_exception[2]))
                        """
                else:
                    # self.log("Ridge single part")
                    try:
                        if lin.isNull():
                            # self.log("Ridge Null")
                            continue

                        polyline = lin.asPolyline()
                        if len(polyline) == 0:
                            continue

                        pt0 = polyline[0]
                        for pt in polyline[1:]:
                            seg = [pt0, pt]
                            feature = QgsFeature(fid)
                            feature.setAttributes([str(fid), self.getGaz(pt0, pt, aPolys, prof), prof])
                            feature.setGeometry(QgsGeometry.fromPolylineXY(seg))
                            feats.append(feature)
                            fid = fid+1
                            pt0 = pt
                    except:
                        # self.log("--------- ERR in {} ---------------".format(prof))
                        exc_type, exc_value, exc_traceback = sys.exc_info()
                        format_exception = traceback.format_exception(exc_type, exc_value, exc_traceback)
                        """
                        self.log(repr(format_exception[0]))
                        self.log(repr(format_exception[1]))
                        self.log(repr(format_exception[2]))
                        """

            hLayer.dataProvider().addFeatures(feats)

            # hLayer.loadNamedStyle(self.plugin_dir + '/cretes.qml')
            hLayer.commitChanges()

        # POI --------------------------------------------------------------------
        aH, aD = self.mt.pY.azimuth(self.mt.pH), self.mt.pY.azimuth(self.mt.pD)
        if aD > aH:
            aH = aH + 360
        angleVue = 2*(aH-aD)

        poiId = self.poiList.itemData(self.poiList.currentIndex())
        poiLayer = None
        if poiId != 0:
            # dy = self.mt.zoneDepth / (self.lineCount.value()-1)
            poiLayer = QgsProject.instance().mapLayer(poiId)
            mapcrs = self.canvas.mapSettings().destinationCrs()
            xMap2Poi = QgsCoordinateTransform(mapcrs, poiLayer.crs(), QgsProject.instance())
            xPoi2Map = QgsCoordinateTransform(poiLayer.crs(), mapcrs, QgsProject.instance())

            # filtrer les points de la zone (convex envelope)
            zon = self.mt.getLines()
            rq = QgsFeatureRequest().setFilterRect(xMap2Poi.transform(zon.boundingBox()))
            rq.setFlags(QgsFeatureRequest.ExactIntersect)
            features = poiLayer.getFeatures(rq)

            hull = zon.convexHull()
            if (poiLayer.wkbType() == QgsWkbTypes.Point or poiLayer.wkbType() == QgsWkbTypes.MultiPoint):
                segAD = QgsGeometry.fromPolylineXY([self.mt.pA, self.mt.pD])
                segCD = QgsGeometry.fromPolylineXY([self.mt.pC, self.mt.pD])
                feats = []
                fid = 1
                for feat in features:
                    poiPointXY = xPoi2Map.transform(feat.geometry().asPoint().x(), feat.geometry().asPoint().y())
                    if hull.contains(poiPointXY):
                        z = self.getElevation(self.xMap2Raster.transform(poiPointXY.x(), poiPointXY.y()))-self.altY
                        # reprojeter les points
                        prof = 0
                        azimuth = 0
                        if self.parallelView.isChecked():
                            depth = segCD.distance(QgsGeometry.fromPointXY(poiPointXY))
                            newX = self.mt.pR.x()+segAD.distance(QgsGeometry.fromPointXY(poiPointXY))
                            zs, prof = self.getZShift(depth)
                            newY = self.mt.pR.y()+zs + z*self.zFactor.value()
                        else:
                            depth = self.mt.pY.distance(poiPointXY)-self.mt.d0
                            azimuth = self.mt.pY.azimuth(poiPointXY)
                            az = azimuth + 360 if aD > azimuth else azimuth
                            fx = (az-aD)/angleVue
                            newX = self.mt.pR.x() + fx*self.mt.finalWidth
                            zs, prof = self.getZShift(depth)
                            newY = self.mt.pR.y()+zs + z*self.zFactor.value()

                        pt = QgsGeometry.fromPointXY(QgsPointXY(newX, newY))
                        visi = self.getVisibility(pt, aPolys, prof)
                        fet0 = QgsFeature(fid)
                        fet0.setAttributes(feat.attributes()+[str(fid), prof, z, depth, visi, azimuth])
                        fid = fid + 1
                        fet0.setGeometry(pt)
                        feats.append(fet0)

                if len(feats) > 0:
                    layer = QgsVectorLayer("MultiPoint?crs={}".format(QgsProject.instance().crs().authid()), "P.O.I.", "memory")
                    QgsProject.instance().addMapLayer(layer)
                    layer.startEditing()
                    layer.dataProvider().addAttributes(poiLayer.dataProvider().fields().toList() + [QgsField("num", QVariant.Int), QgsField("prof", QVariant.Int), QgsField("z", QVariant.Int), QgsField("depth", QVariant.Double, 'double', 4, 1), QgsField("visi", QVariant.Int), QgsField("azimuth", QVariant.Double, 'double', 4, 1)])
                    layer.dataProvider().setEncoding(poiLayer.dataProvider().encoding())
                    layer.updateFields()

                    layer.dataProvider().addFeatures(feats)
                    layer.loadNamedStyle(self.plugin_dir + '/poi.qml')
                    layer.commitChanges()

            if (poiLayer.wkbType() == QgsWkbTypes.LineString or poiLayer.wkbType() == QgsWkbTypes.MultiLineString):
                feats = []
                fid = 1
                for feat in features:
                    geom = QgsGeometry(feat.geometry())
                    geom.transform(xPoi2Map)
                    geom = geom.intersection(hull)
                    # self.log("longueur : {}".format(geom.length()))
                    try:
                        geoms = [geom]
                        for i, cutingLine in enumerate(self.mt.getLines().asMultiPolyline()):
                            # self.log("ligne {}".format(i))
                            newGeoms = []
                            for g in geoms:
                                r, rgeoms, foo = g.splitGeometry(cutingLine, True)
                                # self.log(" r {} découpé en {} pièces".format(r, len(rgeoms)))
                                newGeoms = newGeoms + rgeoms

                            geoms = geoms + newGeoms

                        self.log("nb geoms : {}".format(len(geoms)))
                        for geom in geoms:
                            try:
                                # self.log("geom is polyline ?")
                                # self.log(geom.asWkt())
                                fet = projLineString(feat, geom.asPolyline())
                                if fet is not None:
                                    feats.append(fet)
                                    fid = fid + 1
                            except:
                                collec = geom.asGeometryCollection()
                                # self.log("geom is collection ?")
                                # self.log("{}".format(len(collec)))
                                for geom in collec:
                                    # self.log(geom.asWkt())
                                    fet = projLineString(feat, geom.asPolyline())
                                    if fet is not None:
                                        feats.append(fet)
                                        fid = fid + 1
                    except:
                        raise
                        self.log("--------- ERR in {} ---------------".format(fid))
                        exc_type, exc_value, exc_traceback = sys.exc_info()
                        format_exception = traceback.format_exception(exc_type, exc_value, exc_traceback)
                        self.log(repr(format_exception[0]))
                        self.log(repr(format_exception[1]))
                        self.log(repr(format_exception[2]))

                if len(feats) > 0:
                    layer = QgsVectorLayer("MultiLineString?crs={}".format(QgsProject.instance().crs().authid()), "PROJ.", "memory")
                    QgsProject.instance().addMapLayer(layer)
                    layer.startEditing()
                    layer.dataProvider().addAttributes(poiLayer.dataProvider().fields().toList() + [QgsField("num", QVariant.Int), QgsField("visi", QVariant.Int), QgsField("prof", QVariant.Int)])
                    layer.dataProvider().setEncoding(poiLayer.dataProvider().encoding())
                    layer.updateFields()

                    layer.dataProvider().addFeatures(feats)
                    # layer.loadNamedStyle(self.plugin_dir + '/poi.qml')
                    layer.commitChanges()

            if (poiLayer.wkbType() == QgsWkbTypes.Polygon or poiLayer.wkbType() == QgsWkbTypes.MultiPolygon):
                feats = []
                fid = 1
                for feat in features:
                    geom = QgsGeometry(feat.geometry())
                    geom.transform(xPoi2Map)
                    geom = geom.intersection(hull)
                    try:
                        geoms = [geom]
                        for i, cutingLine in enumerate(self.mt.getLines().asMultiPolyline()):
                            # self.log("ligne {}".format(i))
                            newGeoms = []
                            for g in geoms:
                                r, rgeoms, foo = g.splitGeometry(cutingLine, True)
                                newGeoms = newGeoms + rgeoms

                            geoms = geoms + newGeoms

                        # self.log("nb geoms : {}".format(len(geoms)))
                        for geom in geoms:
                            try:
                                # self.log("geom is polyline ?")
                                # self.log(geom.asWkt())
                                fet = projPolygon(feat, geom.asPolygon())
                                if fet is not None:
                                    feats.append(fet)
                                    fid = fid + 1
                            except:
                                collec = geom.asGeometryCollection()
                                # self.log("geom is collection ?")
                                # self.log("{}".format(len(collec)))
                                for geom in collec:
                                    # self.log(geom.asWkt())
                                    fet = projPolygon(feat, geom.asPolygon())
                                    if fet is not None:
                                        feats.append(fet)
                                        fid = fid + 1
                    except:
                        self.log("--------- ERR in {} ---------------".format(fid))
                        exc_type, exc_value, exc_traceback = sys.exc_info()
                        format_exception = traceback.format_exception(exc_type, exc_value, exc_traceback)
                        self.log(repr(format_exception[0]))
                        self.log(repr(format_exception[1]))
                        self.log(repr(format_exception[2]))

                if len(feats) > 0:
                    layer = QgsVectorLayer("Polygon?crs={}".format(QgsProject.instance().crs().authid()), "PROJ.", "memory")
                    QgsProject.instance().addMapLayer(layer)
                    layer.startEditing()
                    layer.dataProvider().addAttributes(poiLayer.dataProvider().fields().toList() + [QgsField("num", QVariant.Int), QgsField("visi", QVariant.Int), QgsField("prof", QVariant.Int)])
                    layer.dataProvider().setEncoding(poiLayer.dataProvider().encoding())
                    layer.updateFields()

                    layer.dataProvider().addFeatures(feats)
                    # layer.loadNamedStyle(self.plugin_dir + '/poi.qml')
                    sourceStyles = poiLayer.styleManager().mapLayerStyles()
                    layer.styleManager().addStyle('poi', list(sourceStyles.values())[0])
                    layer.commitChanges()

    def build(self):
        """
            Build/Draw the final skylines
        """
        self.info("Build")
        self.buildSlices()

    def on_btnStart_toggled(self, checked):
        self.started = checked
        if (checked):
            if self.start():
                self.btnStart.setText("Cancel")
            else:
                self.btnStart.toggle()
        else:
            self.btnStart.setText("Start")
            self.cancel()

    def on_lineCount_valueChanged(self, v):
        self.mt.updateRubberGeom()

    def on_zShift_valueChanged(self, v):
        self.mt.updateRubberGeom()

    def on_xStep_valueChanged(self, v):
        self.mt.updateRubberGeom()

    def on_elevation_valueChanged(self, v):
        self.mt.updateRubberGeom()

    def on_zFactor_valueChanged(self, v):
        self.mt.updateRubberGeom()

    def on_parallelView_stateChanged(self, v):
        self.mt.updateRubberGeom()

    def on_btnBuild_released(self):
        self.build()
        # self.btnStart.setChecked(False)

    def on_reset_released(self):
        self.mt.pX = None
        self.start()

    def on_rasterList_currentIndexChanged(self, i):
        id = self.rasterList.itemData(self.rasterList.currentIndex())
        self.mntLayer = QgsProject.instance().mapLayer(id)

        try:
            mapcrs = self.canvas.mapSettings().destinationCrs()
            self.xMap2Raster = QgsCoordinateTransform(mapcrs, self.mntLayer.crs(), QgsProject.instance())
        except:
            pass

        # try:
        #     self.xStep.setValue(mntLayer.dataProvider().stepWidth())
        # except:
        #     pass

    def on_btnSave_released(self):
        fileName, _ = QFileDialog.getSaveFileName(self, self.tr("Save parameters"), "", self.tr("Ini files (*.ini)"))
        if fileName:
            s = QSettings(fileName, QSettings.IniFormat)
            s.setValue("dem_slicer/Ax", self.mt.pA.x())
            s.setValue("dem_slicer/Ay", self.mt.pA.y())
            s.setValue("dem_slicer/Bx", self.mt.pB.x())
            s.setValue("dem_slicer/By", self.mt.pB.y())
            s.setValue("dem_slicer/Cx", self.mt.pC.x())
            s.setValue("dem_slicer/Cy", self.mt.pC.y())
            s.setValue("dem_slicer/Dx", self.mt.pD.x())
            s.setValue("dem_slicer/Dy", self.mt.pD.y())
            s.setValue("dem_slicer/Xx", self.mt.pX.x())
            s.setValue("dem_slicer/Xy", self.mt.pX.y())
            s.setValue("dem_slicer/Yx", self.mt.pY.x())
            s.setValue("dem_slicer/Yy", self.mt.pY.y())
            s.setValue("dem_slicer/Hx", self.mt.pH.x())
            s.setValue("dem_slicer/Hy", self.mt.pH.y())
            s.setValue("dem_slicer/Rx", self.mt.pR.x())
            s.setValue("dem_slicer/Ry", self.mt.pR.y())
            s.setValue("dem_slicer/Lx", self.mt.pL.x())
            s.setValue("dem_slicer/Ly", self.mt.pL.y())
            s.setValue("dem_slicer/rotation", self.mt.rotation)

            rId = self.rasterList.itemData(self.rasterList.currentIndex())
            s.setValue("dem_slicer/demLayerId", rId)
            poiId = self.poiList.itemData(self.poiList.currentIndex())
            s.setValue("dem_slicer/decoLayerId", poiId)
            s.setValue("dem_slicer/lineCount", self.lineCount.value())
            s.setValue("dem_slicer/elevation", self.elevation.value())
            s.setValue("dem_slicer/parallelView", 'true' if self.parallelView.isChecked() else 'false')
            s.setValue("dem_slicer/xStep", self.xStep.value())
            s.setValue("dem_slicer/zShift", self.zShift.value())
            s.setValue("dem_slicer/zFactor", self.zFactor.value())
            s.setValue("dem_slicer/renderLines", self.renderLines.isChecked())
            s.setValue("dem_slicer/renderPolygons", self.renderPolygons.isChecked())
            s.setValue("dem_slicer/renderRidges", self.renderRidges.isChecked())

            s.sync()

    def on_btnLoad_released(self):
        fileName, _ = QFileDialog.getOpenFileName(self, self.tr("Load parameters"), "", self.tr("Ini files (*.ini)"))
        if fileName:
            s = QSettings(fileName, QSettings.IniFormat)
            self.mt.pA.setX(float(s.value("dem_slicer/Ax")))
            self.mt.pA.setY(float(s.value("dem_slicer/Ay")))
            self.mt.pB.setX(float(s.value("dem_slicer/Bx")))
            self.mt.pB.setY(float(s.value("dem_slicer/By")))
            self.mt.pC.setX(float(s.value("dem_slicer/Cx")))
            self.mt.pC.setY(float(s.value("dem_slicer/Cy")))
            self.mt.pD.setX(float(s.value("dem_slicer/Dx")))
            self.mt.pD.setY(float(s.value("dem_slicer/Dy")))
            self.mt.pX.setX(float(s.value("dem_slicer/Xx")))
            self.mt.pX.setY(float(s.value("dem_slicer/Xy")))
            self.mt.pY.setX(float(s.value("dem_slicer/Yx")))
            self.mt.pY.setY(float(s.value("dem_slicer/Yy")))
            self.mt.pH.setX(float(s.value("dem_slicer/Hx")))
            self.mt.pH.setY(float(s.value("dem_slicer/Hy")))
            self.mt.pR.setX(float(s.value("dem_slicer/Rx")))
            self.mt.pR.setY(float(s.value("dem_slicer/Ry")))
            self.mt.pL.setX(float(s.value("dem_slicer/Lx")))
            self.mt.pL.setY(float(s.value("dem_slicer/Ly")))
            self.mt.rotation = float(s.value("dem_slicer/rotation"))

            self.rasterList.setCurrentIndex(0)
            for i in range(self.rasterList.count()):
                # If layer is a raster and it is not a multiband type
                if self.rasterList.itemData(i) == s.value("dem_slicer/demLayerId"):
                    self.rasterList.setCurrentIndex(i)

            self.poiList.setCurrentIndex(0)
            for i in range(self.poiList.count()):
                # If layer is a raster and it is not a multiband type
                if self.poiList.itemData(i) == s.value("dem_slicer/decoLayerId"):
                    self.poiList.setCurrentIndex(i)

            self.lineCount.setValue(int(s.value("dem_slicer/lineCount")))
            try:
                self.elevation.setValue(int(s.value("dem_slicer/elevation")))
            except:
                self.elevation.setValue(0)

            self.parallelView.setChecked(s.value("dem_slicer/parallelView") == 'true')
            self.xStep.setValue(float(s.value("dem_slicer/xStep")))
            self.zShift.setValue(float(s.value("dem_slicer/zShift")))
            self.zFactor.setValue(float(s.value("dem_slicer/zFactor")))
            self.renderLines.setChecked(True if s.value("dem_slicer/renderLines") else False)
            self.renderPolygons.setChecked(True if s.value("dem_slicer/renderPolygons") else False)
            self.renderRidges.setChecked(True if s.value("dem_slicer/renderRidges") else False)

            self.mt.rotation_init = self.mt.rotation
            self.mt.pA_init = QgsPointXY(self.mt.pA)
            self.mt.pB_init = QgsPointXY(self.mt.pB)
            self.mt.pC_init = QgsPointXY(self.mt.pC)
            self.mt.pD_init = QgsPointXY(self.mt.pD)
            self.mt.pX_init = QgsPointXY(self.mt.pX)
            self.mt.pY_init = QgsPointXY(self.mt.pY)
            self.mt.pH_init = QgsPointXY(self.mt.pH)
            self.mt.pL_init = QgsPointXY(self.mt.pL)
            self.mt.pR_init = QgsPointXY(self.mt.pR)

            self.mt.updateRubberGeom()

            # self.canvas.setExtent(self.mt.rb.asGeometry().boundingBox())

    def updateZ(self, pt):
        self.altY = self.getElevation(self.xMap2Raster.transform(pt))
        self.labelElevation.setText("Obs. : {} m   +".format(self.altY))


class MapTool(QgsMapTool):
    MODE_NONE = 0
    MODE_PAN = 1
    MODE_ROTATE = 2
    MODE_SCALE = 3
    MODE_SCALE_X = 4
    MODE_SCALE_Y = 5
    MODE_PAN_RESULT = 6

    def __init__(self, widget):
        QgsMapTool.__init__(self, widget.canvas)
        self.widget = widget
        self.canvas = widget.canvas
        self.mode = self.MODE_NONE

        # point cliqué
        self.p0 = None

        # centre rectangle
        self.pX = None

        # sommets du rectangle (accroche dimenssionnement)
        self.pA = None  # hg
        self.pB = None  # hd
        self.pC = None  # bd
        self.pD = None  # bg
        self.zoneWidth = None
        self.zoneDepth = None

        # oeil (accroche rotation)
        self.pY = None

        # placement résultat
        self.pR = None

        # rectangle
        self.rb = QgsRubberBand(self.canvas, QgsWkbTypes.PolygonGeometry)
        self.rb.setStrokeColor(Qt.blue)
        self.rb.setWidth(3)

        self.rbFoc = QgsRubberBand(self.canvas, QgsWkbTypes.LineGeometry)
        self.rbFoc.setStrokeColor(Qt.blue)
        self.rbFoc.setWidth(1)

        # SCALE nodes
        self.rbPA = QgsRubberBand(self.canvas, QgsWkbTypes.PointGeometry)
        self.rbPA.setColor(Qt.red)
        self.rbPA.setWidth(8)
        self.rbPB = QgsRubberBand(self.canvas, QgsWkbTypes.PointGeometry)
        self.rbPB.setColor(Qt.red)
        self.rbPB.setWidth(8)
        self.rbPC = QgsRubberBand(self.canvas, QgsWkbTypes.PointGeometry)
        self.rbPC.setColor(Qt.red)
        self.rbPC.setWidth(8)
        self.rbPD = QgsRubberBand(self.canvas, QgsWkbTypes.PointGeometry)
        self.rbPD.setColor(QColor(255, 50, 150, 255))
        self.rbPD.setWidth(8)
        # scale Y node
        self.rbPH = QgsRubberBand(self.canvas, QgsWkbTypes.PointGeometry)
        self.rbPH.setColor(Qt.red)
        self.rbPH.setWidth(8)
        # scale X node
        self.rbPL = QgsRubberBand(self.canvas, QgsWkbTypes.PointGeometry)
        self.rbPL.setColor(Qt.red)
        self.rbPL.setWidth(8)

        # final pan
        self.rbPan = QgsRubberBand(self.canvas, QgsWkbTypes.PointGeometry)
        self.rbPan.setColor(QColor(200, 120, 50, 255))
        self.rbPan.setWidth(8)

        # ROTATE node
        self.rbPY = QgsRubberBand(self.canvas, QgsWkbTypes.PointGeometry)
        self.rbPY.setColor(Qt.blue)
        self.rbPY.setWidth(6)
        # self.rbPR.setSvgIcon("./arrow_curved_left.svg", QPoint(0, 0))

        # cutting lines
        self.rbLines = QgsRubberBand(self.canvas, QgsWkbTypes.LineGeometry)
        self.rbLines.setColor(QColor(40, 180, 30, 255))
        self.rbLines.setWidth(1.5)

        # skylines
        self.rbThumbnail = QgsRubberBand(self.canvas, QgsWkbTypes.PolygonGeometry)
        self.rbThumbnail.setStrokeColor(QColor(200, 120, 70, 150))
        self.rbThumbnail.setWidth(0.8)

        self.rbSkylines = QgsRubberBand(self.canvas, QgsWkbTypes.LineGeometry)
        self.rbSkylines.setColor(QColor(180, 100, 50, 100))
        self.rbSkylines.setWidth(1)

        self.rubbers = [self.rb, self.rbPA, self.rbPB, self.rbPC, self.rbPD, self.rbPY, self.rbLines, self.rbPH, self.rbPL, self.rbPan, self.rbSkylines, self.rbFoc, self.rbThumbnail]

    def hide(self):
        for rb in self.rubbers:
            rb.reset()

    def getFinalLinesGenerator(self):
        """
        Calcul de l'emplacement des lignes projetées, selon :
            - altitude de l'observateur
            - zone visée
        """
        nbLines = self.widget.lineCount.value()
        dx = self.zoneDepth / (nbLines-1)
        z = self.widget.elevation.value()
        for ixL in range(nbLines)[::-1]:
            dist = self.d0 + (dx * ixL)
            alpha = math.atan(z / dist)
            dh = (dist-self.d0) * math.tan(alpha)  # (z/dist)
            p1 = QgsPointXY(self.pR.x(), self.pR.y() + dh + ixL*self.widget.zShift.value())
            p2 = QgsPointXY(self.pR.x() + self.finalWidth, self.pR.y() + dh + ixL*self.widget.zShift.value())
            g = [p1, p2]
            yield g

    def updateRubberGeom(self):
        if self.pA is None:
            return

        self.zoneWidth = self.pA.distance(self.pB)
        self.zoneDepth = self.pA.distance(self.pD)
        self.pM = QgsPointXY((self.pC.x()+self.pD.x())/2, (self.pC.y()+self.pD.y())/2)
        # distance entre observateur et milieu segment [CD] : premier slice
        self.d0 = self.pM.distance(self.pY)
        self.widget.updateZ(self.pY)

        self.rb.setToGeometry(QgsGeometry.fromPolygonXY([[self.pD, self.pA, self.pB, self.pC, self.pD]]))
        self.rbFoc.setToGeometry(QgsGeometry.fromPolylineXY([self.pD, self.pY, self.pC]))

        for p, rb in [[self.pA, self.rbPA], [self.pB, self.rbPB], [self.pC, self.rbPC], [self.pD, self.rbPD], [self.pY, self.rbPY], [self.pH, self.rbPH], [self.pL, self.rbPL], [self.pR, self.rbPan]]:
            rb.setToGeometry(QgsGeometry.fromPointXY(p))

        flancGauche = QgsGeometry.fromPolylineXY([self.pA, self.pD]).densifyByCount(self.widget.lineCount.value()-2).asPolyline()
        flancDroit = QgsGeometry.fromPolylineXY([self.pB, self.pC]).densifyByCount(self.widget.lineCount.value()-2).asPolyline()

        # dessin des lignes de coupe
        polylineX = []
        if self.widget.parallelView.isChecked():
            polyline = list(zip(flancGauche, flancDroit))

            backSide = QgsGeometry.fromPolylineXY([self.pA, self.pB]).densifyByDistance(self.widget.xStep.value()).asPolyline()
            frontSide = QgsGeometry.fromPolylineXY([self.pD, self.pC]).densifyByDistance(self.widget.xStep.value()).asPolyline()
            polylineX = list(zip(frontSide[:5], backSide[:5]))

            # largeur de la zone projetée
            self.finalWidth = self.zoneWidth

        else:
            # dy = self.pA.distance(self.pD) / (self.widget.lineCount.value()-1)
            aH = self.pY.azimuth(self.pH)
            aD = self.pY.azimuth(self.pD)
            if aD > aH:
                aH = aH + 360

            alpha = aH-aD
            dAlphaDetail = 2 * alpha / (self.finalWidth / self.widget.xStep.value())
            dAlpha = 2 * alpha / 12
            # self.widget.log("{} {} {}".format(str(aH), str(aD), str(dAlpha)))
            # dAlpha = dAlpha if dAlpha > 0 else -dAlpha

            aPrim = QgsGeometry.fromPointXY(self.pH)
            aPrim.rotate(-alpha, self.pY)
            dPrim = QgsGeometry.fromPointXY(self.pM)
            dPrim.rotate(-alpha, self.pY)

            gauche = QgsGeometry.fromPolylineXY([aPrim.asPoint(), dPrim.asPoint()]).densifyByCount(self.widget.lineCount.value()-2).asPolyline()
            polyline = []
            for p in gauche:
                line = []
                for nx in range(1+12):
                    g = QgsGeometry.fromPointXY(p)
                    g.rotate(nx*dAlpha, self.pY)
                    line.append(g.asPoint())

                polyline.append(line)

            for _ in range(5):
                seg = QgsGeometry.fromPolylineXY([aPrim.asPoint(), dPrim.asPoint()]).asPolyline()
                polylineX.append(seg)
                aPrim.rotate(dAlphaDetail, self.pY)
                dPrim.rotate(dAlphaDetail, self.pY)

            # largeur de la zone projetée
            self.finalWidth = QgsGeometry.fromPolylineXY(polyline[int(len(polyline)/2)]).length()

        self.cuttingLines = polyline
        self.rbLines.setToGeometry(QgsGeometry.fromMultiPolylineXY(polylineX + polyline[0:50]+polyline[::max(1, 1+int(len(polyline)/50))][-50:]))

        # rendu final
        polyline = []
        for line in self.getFinalLinesGenerator():
            polyline.append(line)

        self.skyLines = polyline
        self.rbSkylines.setToGeometry(QgsGeometry.fromMultiPolylineXY(polyline[::max(1, 1+int(len(polyline)/50))][0:50]))

        try:
            self.rbThumbnail.setToGeometry(self.widget.getThumbnailGeom())
        except:
            exc_type, exc_value, exc_traceback = sys.exc_info()
            format_exception = traceback.format_exception(exc_type, exc_value, exc_traceback)
            self.widget.log(repr(format_exception[0]))
            self.widget.log(repr(format_exception[1]))
            self.widget.log(repr(format_exception[2]))

        nbPoints = int(len(polyline)*(self.finalWidth / self.widget.xStep.value()))
        alert = ''
        if (nbPoints > 100000):
            alert = alert + 'Attention : {} points\n'.format(nbPoints)

        self.widget.alert.setText(alert)

    def getLines(self):
        return QgsGeometry.fromMultiPolylineXY(self.cuttingLines)

    def getSampleLines(self):
        return [self.cuttingLines[0], self.cuttingLines[1]] + self.cuttingLines[2:-1][::max(1, 1+int((len(self.cuttingLines)-3)/9))] + [self.cuttingLines[-1]]

    def getSkylines(self):
        return QgsGeometry.fromMultiPolylineXY(self.skyLines)

    def getSampleSkylines(self):
        return [self.skyLines[0], self.skyLines[1]] + self.skyLines[2:-1][::max(1, 1+int((len(self.skyLines)-3)/9))] + [self.skyLines[-1]]

    def newRubber(self):
        if self.pX is not None:
            self.updateRubberGeom()
            return

        # default parameters
        h = 2*self.widget.canvas.extent().height()/3/20
        self.widget.xStep.setValue(round(h/2, int(2-math.log10(h/2))))

        # première emprise, selon vue courante
        h = self.canvas.extent().height()/6
        c = self.canvas.extent().center()
        rubberExtent = QgsRectangle(QgsPointXY(c.x()-h, c.y()-h), QgsPointXY(c.x()+h, c.y()+h))
        self.rotation = 0.0
        width = rubberExtent.xMaximum()-rubberExtent.xMinimum()
        height = rubberExtent.yMaximum()-rubberExtent.yMinimum()

        # centre rectangle
        self.pX = QgsPointXY(rubberExtent.xMinimum()+width/2, rubberExtent.yMinimum()+height/2)
        # sommets du rectangle (accroche dimenssionnement)
        self.pA = QgsPointXY(rubberExtent.xMinimum(), rubberExtent.yMaximum())
        self.pB = QgsPointXY(rubberExtent.xMaximum(), rubberExtent.yMaximum())
        self.pC = QgsPointXY(rubberExtent.xMaximum(), rubberExtent.yMinimum())
        self.pD = QgsPointXY(rubberExtent.xMinimum(), rubberExtent.yMinimum())
        # accroches H / L
        self.pH = QgsPointXY((self.pA.x()+self.pB.x())/2, (self.pA.y()+self.pB.y())/2)
        self.pL = QgsPointXY((self.pB.x()+self.pC.x())/2, (self.pB.y()+self.pC.y())/2)
        # oeil (accroche rotation)
        self.pY = QgsPointXY(self.pX.x(), self.pX.y()-2*height/3)

        self.pM = QgsPointXY((self.pC.x()+self.pD.x())/2, (self.pC.y()+self.pD.y())/2)

        self.pR = QgsPointXY(self.pD.x()+width/2, self.pD.y()+height/2)

        self.rotation_init = self.rotation
        self.pA_init = QgsPointXY(self.pA)
        self.pB_init = QgsPointXY(self.pB)
        self.pC_init = QgsPointXY(self.pC)
        self.pD_init = QgsPointXY(self.pD)
        self.pX_init = QgsPointXY(self.pX)
        self.pY_init = QgsPointXY(self.pY)
        self.pH_init = QgsPointXY(self.pH)
        self.pL_init = QgsPointXY(self.pL)
        self.pR_init = QgsPointXY(self.pR)

        self.updateRubberGeom()

    def canvasPressEvent(self, event):
        x = event.pos().x()
        y = event.pos().y()
        self.p0 = self.canvas.getCoordinateTransform().toMapCoordinates(x, y)
        # QgsMessageLog.logMessage("{} {}".format(self.p0.x(), self.p0.y()), 'Extensions')

        distPA = self.p0.distance(self.pA) / self.canvas.mapUnitsPerPixel()
        distPB = self.p0.distance(self.pB) / self.canvas.mapUnitsPerPixel()
        distPC = self.p0.distance(self.pC) / self.canvas.mapUnitsPerPixel()
        distPD = self.p0.distance(self.pD) / self.canvas.mapUnitsPerPixel()
        distPY = self.p0.distance(self.pY) / self.canvas.mapUnitsPerPixel()
        distPH = self.p0.distance(self.pH) / self.canvas.mapUnitsPerPixel()
        distPL = self.p0.distance(self.pL) / self.canvas.mapUnitsPerPixel()
        distPR = self.p0.distance(self.pR) / self.canvas.mapUnitsPerPixel()

        if distPA < 6 or distPB < 6 or distPC < 6 or distPD < 6:
            self.mode = self.MODE_SCALE
            return

        if distPH < 6:
            self.mode = self.MODE_SCALE_Y
            return

        if distPL < 6:
            self.mode = self.MODE_SCALE_X
            return

        if distPY < 6:
            self.mode = self.MODE_ROTATE
            return

        if distPR < 6:
            self.mode = self.MODE_PAN_RESULT
            return

        if self.rb.asGeometry().contains(self.p0):
            self.mode = self.MODE_PAN
            return

    def canvasMoveEvent(self, event):
        if self.mode == self.MODE_NONE:
            return

        x = event.pos().x()
        y = event.pos().y()
        pt = self.canvas.getCoordinateTransform().toMapCoordinates(x, y)
        dx = pt.x()-self.p0.x()
        dy = pt.y()-self.p0.y()

        # déplacement
        if self.mode == self.MODE_PAN:
            for p, p_ini in [[self.pA, self.pA_init], [self.pB, self.pB_init], [self.pC, self.pC_init], [self.pD, self.pD_init],
                             [self.pX, self.pX_init], [self.pY, self.pY_init],
                             [self.pH, self.pH_init], [self.pL, self.pL_init]]:
                p.setX(p_ini.x()+dx)
                p.setY(p_ini.y()+dy)

        # déplacement résultat
        if self.mode == self.MODE_PAN_RESULT:
            for p, p_ini in [[self.pR, self.pR_init]]:
                p.setX(p_ini.x()+dx)
                p.setY(p_ini.y()+dy)

        # redimensionement Horizontal + Vertical
        if self.mode == self.MODE_SCALE:
            d_old = self.pA_init.distance(self.pX_init)
            d_new = pt.distance(self.pX_init)
            dd = d_new/d_old

            for p, p_ini in [[self.pA, self.pA_init], [self.pB, self.pB_init], [self.pC, self.pC_init], [self.pD, self.pD_init],
                             [self.pY, self.pY_init], [self.pH, self.pH_init], [self.pL, self.pL_init]]:
                dx = dd*(p_ini.x()-self.pX.x())
                dy = dd*(p_ini.y()-self.pX.y())
                p.setX(self.pX.x()+dx)
                p.setY(self.pX.y()+dy)

        # Redimenssionement horizontal
        if self.mode == self.MODE_SCALE_X:
            d_old = self.pL_init.distance(self.pX_init)
            d_new = pt.distance(self.pX_init)
            dd = d_new/d_old
            if dd < 0.001:
                dd = 0.001
            # QgsMessageLog.logMessage("d_new {}".format(d_new), 'Extensions')

            dx = dd*(self.pL_init.x()-self.pX.x())
            dy = dd*(self.pL_init.y()-self.pX.y())
            self.pL.setX(self.pX.x()+dx)
            self.pL.setY(self.pX.y()+dy)

            centre = self.pH
            for p, p_ini in [[self.pA, self.pA_init], [self.pB, self.pB_init]]:
                dx = dd*(p_ini.x()-centre.x())
                dy = dd*(p_ini.y()-centre.y())
                p.setX(centre.x()+dx)
                p.setY(centre.y()+dy)

            centre = self.pM
            for p, p_ini in [[self.pC, self.pC_init], [self.pD, self.pD_init]]:
                dx = dd*(p_ini.x()-centre.x())
                dy = dd*(p_ini.y()-centre.y())
                p.setX(centre.x()+dx)
                p.setY(centre.y()+dy)

        # Redimenssionement vertical
        if self.mode == self.MODE_SCALE_Y:
            d_old = self.pH_init.distance(self.pX_init)
            d_new = pt.distance(self.pX_init)
            dd = d_new/d_old
            if dd < 0.001:
                dd = 0.001
            # QgsMessageLog.logMessage("d_new {}".format(d_new), 'Extensions')

            dx = dd*(self.pH_init.x()-self.pX.x())
            dy = dd*(self.pH_init.y()-self.pX.y())
            self.pH.setX(self.pX.x()+dx)
            self.pH.setY(self.pX.y()+dy)

            centre = self.pL
            for p, p_ini in [[self.pB, self.pB_init], [self.pC, self.pC_init]]:
                dx = dd*(p_ini.x()-centre.x())
                dy = dd*(p_ini.y()-centre.y())
                p.setX(centre.x()+dx)
                p.setY(centre.y()+dy)

            centre = QgsPointXY((self.pA.x()+self.pD.x())/2, (self.pA.y()+self.pD.y())/2)
            for p, p_ini in [[self.pA, self.pA_init], [self.pD, self.pD_init]]:
                dx = dd*(p_ini.x()-centre.x())
                dy = dd*(p_ini.y()-centre.y())
                p.setX(centre.x()+dx)
                p.setY(centre.y()+dy)

        if self.mode == self.MODE_ROTATE:
            self.pY.setX(self.pY_init.x()+dx)
            self.pY.setY(self.pY_init.y()+dy)

            azimuth = self.pX.azimuth(pt)
            theta = azimuth - self.rotation_init + 180
            self.rotation = self.rotation_init + theta

            for a, i in [[self.pA, self.pA_init], [self.pB, self.pB_init], [self.pC, self.pC_init], [self.pD, self.pD_init], [self.pH, self.pH_init], [self.pL, self.pL_init]]:
                A = QgsGeometry.fromPointXY(i)
                A.rotate(theta, self.pX)
                a.setX(A.asPoint().x())
                a.setY(A.asPoint().y())

        self.updateRubberGeom()

    def canvasReleaseEvent(self, event):
        self.pA_init = QgsPointXY(self.pA)
        self.pB_init = QgsPointXY(self.pB)
        self.pC_init = QgsPointXY(self.pC)
        self.pD_init = QgsPointXY(self.pD)
        self.pX_init = QgsPointXY(self.pX)
        self.pY_init = QgsPointXY(self.pY)
        self.pH_init = QgsPointXY(self.pH)
        self.pL_init = QgsPointXY(self.pL)
        self.pR_init = QgsPointXY(self.pR)
        self.rotation_init = self.rotation

        self.mode = self.MODE_NONE

    def activate(self):
        pass
        """self.widget.rasterList.clear()
        for layer in QgsProject.instance().mapLayers().values():
            # If layer is a raster and it is not a multiband type
            if layer.type() == QgsMapLayer.RasterLayer:  # and layer.renderer().type() != "multibandcolor":
                # Add to list
                self.widget.rasterList.addItem(layer.name(), layer.id())
        """

    def deactivate(self):
        self.hide()

    def isZoomTool(self):
        return False

    def isTransient(self):
        return False

    def isEditTool(self):
        return True
