"""
/***************************************************************************
 DemSlicerDockWidget
                                 A QGIS plugin
 D.E.M. slicer, produces lines
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2019-10-24
        git sha              : $Format:%H$
        copyright            : (C) 2019 by xc
        email                : xavier.culos@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from qgis.PyQt import QtWidgets, uic
from qgis.PyQt.QtWidgets import QFileDialog
from qgis.PyQt.QtCore import (
    QCoreApplication,
    QTranslator,
    pyqtSignal,
    Qt,
    QVariant,
    QSettings,
)
from qgis.PyQt.QtGui import QColor
from qgis.core import (
    Qgis,
    QgsWkbTypes,
    QgsGeometry,
    QgsPoint, QgsPointXY,
    QgsMessageLog,
    QgsProject,
    QgsMapLayer,
    QgsVectorLayer,
    QgsField,
)
from qgis.core import (
    QgsFeature,
    QgsCoordinateTransform,
    QgsFeatureRequest,
    QgsRectangle,
)
from qgis.gui import QgsRubberBand, QgsMapTool
import math
import inspect

FORM_CLASS, _ = uic.loadUiType(
    os.path.join(os.path.dirname(__file__), "dem_slicer_dockwidget_base.ui")
)


class DemSlicerDockWidget(QtWidgets.QDockWidget, FORM_CLASS):

    closingPlugin = pyqtSignal()
    plugin = None

    def __init__(self, _plugin, parent=None):
        """Constructor."""
        super(DemSlicerDockWidget, self).__init__(parent)
        self.setupUi(self)
        self.plugin = _plugin
        self.canvas = self.plugin.iface.mapCanvas()
        self.started = False
        self.btnStart.setCheckable(True)
        self.mt = MapTool(self)
        self.plugin_dir = os.path.dirname(__file__)

        locale = QSettings().value("locale/userLocale")[0:2]
        localePath = os.path.join(self.plugin_dir, "i18n", "{}.qm".format(locale))
        self.info(localePath)

        if os.path.exists(localePath):
            self.translator = QTranslator()
            self.translator.load(localePath)
            QCoreApplication.installTranslator(self.translator)

        for widget in [
            self.rasterListLabel,
            self.btnBuild,
            self.btnStart,
            self.lineCountLabel,
            self.zFactorLabel,
            self.xStepLabel,
            self.zShiftLabel,
            self.renderLines,
            self.renderPolygons,
            self.renderRidges,
            self.parallelView,
            self.poiListLabel,
            self.labelElevation,
            self.btnLoad,
            self.labelBase,
        ]:
            widget.setText(self.tr(widget.text()))

        for widget in [self.btnSave, self.reset, self.btnLoad]:
            widget.setToolTip(self.tr(widget.toolTip()))

        self.widget2Enable = [
            self.lineCount,
            self.rasterList,
            self.poiList,
            self.xStep,
            self.zShift,
            self.zFactor,
            self.renderLines,
            self.renderPolygons,
            self.renderRidges,
            self.btnBuild,
            self.progressBar,
            self.parallelView,
            self.reset,
            self.btnLoad,
            self.btnSave,
            self.elevation,
            self.base,
        ]

        self.alert.setText("")

    def tr(self, message):
        return QCoreApplication.translate("DemSlicer", message)

    def closeEvent(self, event):
        self.closingPlugin.emit()
        event.accept()

    def info(self, message, d=1):
        self.plugin.iface.messageBar().pushMessage(
            "DEM Slicer", self.tr(message), level=Qgis.Info, duration=d
        )

    def log(self, message):
        QgsMessageLog.logMessage(str(message), "Extensions")

    def start(self):
        """Start the processus : activates tools, builds rubber bands..."""
        self.info("Start")

        rId = self.rasterList.itemData(self.rasterList.currentIndex())
        poiId = self.poiList.itemData(self.poiList.currentIndex())
        self.rasterList.clear()
        self.poiList.clear()
        self.poiList.addItem("- None -", 0)
        i, j = 0, 1
        for layer in QgsProject.instance().mapLayers().values():
            # If layer is a raster and it is not a multiband type
            if layer.type() == QgsMapLayer.RasterLayer:
                # Add to list
                self.rasterList.addItem(layer.name(), layer.id())
                if layer.id() == rId:
                    self.rasterList.setCurrentIndex(i)
                i = i + 1

            if layer.type() == QgsMapLayer.VectorLayer:
                # Add to list
                self.poiList.addItem(layer.name(), layer.id())
                if layer.id() == poiId:
                    self.poiList.setCurrentIndex(j)
                j = j + 1

        if i == 0:
            return False

        for w in self.widget2Enable:
            w.setEnabled(True)
        # self.elevation.setEnabled(not self.parallelView.isChecked())

        self.canvas.setMapTool(self.mt)

        self.mt.newRubber()

        return True

    def cancel(self):
        self.mt.hide()
        self.canvas.unsetMapTool(self.mt)

        for w in self.widget2Enable:
            w.setEnabled(False)

    def getElevation(self, point):
        """
        Returns elevation

        :param point: The point to identify elevation (mntLayer crs)
        :type point: QgsPointXY

        :return: The elevation (first band value)
        :rtype: int
        """
        try:
            v, ok = self.mntLayer.dataProvider().sample(point, 1)
            return v if ok else 0
        except Exception:
            return 0

    def getGaz(self, pt1, pt2, polys, prof):
        """
        Calculates the number of hidden profiles, behind a segment

        :param pt1: first point of the segment
        :param pt2: second point
        :param polys: profiles
        :param prof: 'depth' of the current segment

        :return: Number of hidden profiles
        :rtype: int
        """
        pt = QgsPointXY((pt1.x() + pt2.x()) / 2, (pt1.y() + pt2.y()) / 2)

        for i, p in enumerate(polys[::-1]):
            if i > prof and p.contains(pt):
                return i - prof

        return None

    def getVisibility(self, pt, polys, prof):
        """
        Returns if then point is visible (> 0) or hidden (<= 0) by the profiles
        """
        visi = 1
        for i, p in enumerate(polys[::-1]):
            if prof > i and p.contains(pt):
                visi = visi - 1

            if visi <= -10:
                break

        return visi

    def getNewZ(self, zTarget, depth):
        """
        :param zTarget : point target altitude
        :param depth : distance (depth) between observer and point (2d)

        :return: new projected z
        """
        # Altitude de la cible par rapport Ã  l'observateur
        if self.parallelView.isChecked():
            z = self.elevation.value()
            # alpha = math.atan(z / depth)
            # dh = (depth - self.mt.d0) * math.tan(alpha)
            dh = (depth - self.mt.d0) * ((z+self.altY) / (self.mt.zoneDepth))
            return zTarget + dh
        else:
            h = zTarget - self.elevation.value() - self.altY
            return h * ((self.mt.horizon) / depth)

    def getProf(self, depth):
        # distance entre deux profils
        dd = self.mt.zoneDepth / (self.lineCount.value() - 1)
        # indice du profil
        ixL = round(depth / dd)
        return ixL

    def getProjectionPoint(self, pt):
        # new Y
        d = (self.mt.d0 + self.mt.segCD.distance(QgsGeometry.fromPointXY(pt))) if self.parallelView.isChecked() else self.mt.pY.distance(pt)
        z = self.getElevation(self.xMap2Raster.transform(pt.x(), pt.y()))
        newZ = self.getNewZ(z, d)
        zf = self.zFactor.value()
        newY = (
            self.mt.pR.y()
            + (newZ * zf)
            + (d * self.zShift.value() / self.mt.zoneDepth)
        )

        # new X
        if self.parallelView.isChecked():
            newX = self.mt.pR.x() + self.mt.segAD.distance(QgsGeometry.fromPointXY(pt))
        else:
            aLeft = self.mt.pY.azimuth(self.mt.pD)
            aRight = self.mt.pY.azimuth(self.mt.pC)
            if aRight < aLeft:
                aRight = aRight + 360
            aPeak = self.mt.pY.azimuth(pt)
            if aPeak < aLeft:
                aPeak = aPeak + 360
            newX = self.mt.pR.x() + ((aPeak-aLeft)/(aRight-aLeft))*self.mt.finalWidth

        return QgsPointXY(newX, newY)

    def getThumbnailGeom(self):
        dx = self.mt.finalWidth / 15
        lines = self.mt.getSampleLines()
        geom = QgsGeometry.fromMultiPolylineXY(lines)
        lineCount = len(lines)
        if self.parallelView.isChecked():
            polylineIn = geom.densifyByDistance(dx).asMultiPolyline()
        else:
            aH = self.mt.pY.azimuth(self.mt.pH)
            aD = self.mt.pY.azimuth(self.mt.pD)
            if aD > aH:
                aH = aH + 360

            alpha = aH - aD
            dAlphaDetail = 2.0 * alpha / (self.mt.finalWidth / self.xStep.value())
            dAlpha = 2.0 * alpha / (self.mt.finalWidth / dx)

            aPrim = QgsGeometry.fromPointXY(self.mt.pH)
            aPrim.rotate(-alpha, self.mt.pY)
            aPrim = aPrim.asPoint()
            dPrim = QgsGeometry.fromPointXY(self.mt.pM)
            dPrim.rotate(-alpha, self.mt.pY)
            dPrim = dPrim.asPoint()

            leftEdge = (
                QgsGeometry.fromPolylineXY([aPrim, dPrim])
                .densifyByCount(lineCount - 2)
                .asPolyline()
            )
            polyline = []
            samplePointNumber = 2 + round(self.mt.finalWidth / dx)
            for p in leftEdge:
                line = []

                # first point
                line.append(p)

                # second
                g = QgsGeometry.fromPointXY(p)
                g.rotate(dAlphaDetail, self.mt.pY)
                line.append(g.asPoint())

                # third
                g = QgsGeometry.fromPointXY(p)
                g.rotate(2 * dAlphaDetail, self.mt.pY)
                line.append(g.asPoint())

                g = QgsGeometry.fromPointXY(p)
                for nx in range(samplePointNumber):
                    if nx * dAlpha > 2 * dAlphaDetail:
                        g.rotate(dAlpha, self.mt.pY)
                        line.append(g.asPoint())

                # last ?
                if samplePointNumber * dAlpha < 2.0 * alpha + 0.001:
                    g = QgsGeometry.fromPointXY(p)
                    g.rotate(2.0 * alpha, self.mt.pY)
                    line.append(g.asPoint())

                polyline.append(line)

            polylineIn = polyline

        lines = self.mt.getSampleSkylines()
        geom = QgsGeometry.fromMultiPolylineXY(lines)
        polylineOut = geom.densifyByDistance(dx).asMultiPolyline()
        xmin = geom.boundingBox().xMinimum()
        xmax = geom.boundingBox().xMaximum()
        ymin = geom.boundingBox().yMinimum()

        # search for Z values
        aPolys = []
        for lineIn, lineOut in zip(polylineIn, polylineOut):
            # distance Ã  l'observateur et altitude
            ds, zs = map(
                list,
                zip(
                    *[
                        (
                            # distance ligne observateur - point si //
                            # distance entre les deux points sinon
                            self.mt.d0
                            + self.mt.segCD.distance(QgsGeometry.fromPointXY(point))
                            if self.parallelView.isChecked()
                            else self.mt.pY.distance(point),
                            self.getElevation(
                                self.xMap2Raster.transform(point.x(), point.y())
                            ),
                        )
                        for point in lineIn
                    ]
                ),
            )

            zf = self.zFactor.value()
            for d, z, point in zip(ds, zs, lineOut):
                # ligne Ã©chantillon
                newZ = self.getNewZ(z, d)
                newY = (
                    self.mt.pR.y()
                    + (newZ * zf)
                    + (d * self.zShift.value() / self.mt.zoneDepth)
                )
                if newY < ymin:
                    ymin = newY
                point.setY(newY)

            lineOut.append(QgsPointXY(xmax, ymin-self.base.value()))
            lineOut.append(QgsPointXY(xmin, ymin-self.base.value()))
            aPolys.append([lineOut])

        self.yMin = ymin
        return QgsGeometry.fromPolylineXY(aPolys[0][0][:-2]), QgsGeometry.fromMultiPolygonXY(aPolys)

    def getPeakGeom(self, ptPeak):
        ptXY = self.getProjectionPoint(ptPeak)
        return QgsGeometry.fromPointXY(ptXY)

    def projPolyline(self, polyline):
        for i, pt in enumerate(polyline):
            ptXY = self.getProjectionPoint(pt)
            polyline[i].setX(ptXY.x())
            polyline[i].setY(ptXY.y())

    def buildLayer(self, layer, aLines, progress):
        layer.startEditing()
        layer.dataProvider().addAttributes(
            [QgsField("demslicer_num", QVariant.Int)]
        )
        layer.updateFields()
        feats = []
        for fid, lin in enumerate(aLines):
            self.progressBar.setValue(progress)
            progress = progress + 1
            feature = QgsFeature(fid)
            feature.setAttributes([str(fid)])
            feature.setGeometry(lin)
            feats.append(feature)

        layer.dataProvider().addFeatures(feats)
        layer.commitChanges()
        QgsProject.instance().addMapLayer(layer)

    def buildSlices(self):

        def projLineString(feat, polyline):
            # reprojet points
            self.projPolyline(polyline)
            if len(polyline) > 1:
                if self.parallelView.isChecked():
                    depth = self.mt.d0 + self.mt.segCD.distance(QgsGeometry.fromPointXY(polyline[0]))
                else:
                    depth = self.mt.pY.distance(polyline[0])
                prof = self.getProf(depth)
                visi = self.getVisibility(polyline[1], aPolys, prof)
                fet0 = QgsFeature(fid)
                fet0.setAttributes(feat.attributes() + [str(fid), visi, prof])
                fet0.setGeometry(QgsGeometry.fromPolylineXY(polyline))
                return fet0
            else:
                return None

        def projPolygon(feat, polygon):
            # reprojet points
            prof = 0
            self.log("in projPolyline, altY = {}".format(self.altY))
            for polyline in polygon:
                self.projPolyline(polyline)
                if self.parallelView.isChecked():
                    depth = self.mt.d0 + self.mt.segCD.distance(QgsGeometry.fromPointXY(polyline[0]))
                else:
                    depth = self.mt.pY.distance(polyline[0])
                prof = self.getProf(depth)

            try:
                visi = self.getVisibility(polygon[0][1], aPolys, prof)
                fet0 = QgsFeature(fid)
                fet0.setAttributes(feat.attributes() + [str(fid), visi, prof])
                fet0.setGeometry(QgsGeometry.fromPolygonXY(polygon))
                return fet0
            except Exception:
                return None

        # initial bbox ... lines
        dx = self.xStep.value()
        geom = self.mt.getLines()
        if self.parallelView.isChecked():
            polylineIn = geom.densifyByDistance(dx).asMultiPolyline()
        else:
            aH = self.mt.pY.azimuth(self.mt.pH)
            aD = self.mt.pY.azimuth(self.mt.pD)
            if aD > aH:
                aH = aH + 360

            alpha = aH - aD
            dAlpha = 2 * alpha / (self.mt.finalWidth / dx)
            aPrim = QgsGeometry.fromPointXY(self.mt.pH)
            aPrim.rotate(-alpha, self.mt.pY)
            aPrim = aPrim.asPoint()
            dPrim = QgsGeometry.fromPointXY(self.mt.pM)
            dPrim.rotate(-alpha, self.mt.pY)
            dPrim = dPrim.asPoint()

            leftEdge = (
                QgsGeometry.fromPolylineXY([aPrim, dPrim])
                .densifyByCount(self.lineCount.value() - 2)
                .asPolyline()
            )
            polyline = []
            for p in leftEdge:
                line = []
                for nx in range(2 + int(self.mt.finalWidth / dx)):
                    g = QgsGeometry.fromPointXY(p)
                    g.rotate(nx * dAlpha, self.mt.pY)
                    line.append(g.asPoint())

                polyline.append(line)

            polylineIn = polyline

        geom = self.mt.getSkylines()
        polylineOut = geom.densifyByDistance(dx).asMultiPolyline()
        xmin = geom.boundingBox().xMinimum()
        xmax = geom.boundingBox().xMaximum()

        progress = 0
        self.progressBar.setMaximum(
            len(polylineIn)
            + (len(polylineIn) * self.renderLines.isChecked())
            + (len(polylineIn) * self.renderPolygons.isChecked())
            + (2 * len(polylineIn) * self.renderRidges.isChecked())
        )
        aLines = []
        aPolys = []
        zf = self.zFactor.value()

        # search for Z values
        for lineIn, lineOut in zip(polylineIn, polylineOut):
            self.progressBar.setValue(progress)
            progress = progress + 1
            ds, zs = map(
                list,
                zip(
                    *[
                        (
                            # distance ligne observateur - point si //
                            # distance entre les deux points sinon
                            self.mt.d0
                            + self.mt.segCD.distance(QgsGeometry.fromPointXY(point))
                            if self.parallelView.isChecked()
                            else self.mt.pY.distance(point),
                            self.getElevation(
                                self.xMap2Raster.transform(point.x(), point.y())
                            ),
                        )
                        for point in lineIn
                    ]
                ),
            )

            for d, z, point in zip(ds, zs, lineOut):
                newZ = self.getNewZ(z, d)
                newY = (
                    self.mt.pR.y()
                    + (newZ * zf)
                    + (d * self.zShift.value() / self.mt.zoneDepth)
                )
                point.setY(newY)

            aLines.append(QgsGeometry.fromPolylineXY(lineOut))

            lineOut.append(QgsPointXY(xmax, self.yMin-self.base.value()))
            lineOut.append(QgsPointXY(xmin, self.yMin-self.base.value()))
            aPolys.append(QgsGeometry.fromPolygonXY([lineOut]))

        # Compass ------------------------------------------------------------------------
        if not self.parallelView.isChecked():
            compass = QgsVectorLayer(
                "Point?crs={}".format(QgsProject.instance().crs().authid()),
                "Compass",
                "memory",
            )
            aLeft = self.mt.pY.azimuth(self.mt.pD)
            aRight = self.mt.pY.azimuth(self.mt.pC)
            self.log("{} {}".format(aLeft, aRight))
            if aLeft > aRight:
                aRight = aRight + 360

            compass.startEditing()
            feats = []
            compass.dataProvider().addAttributes(
                [QgsField("demslicer_azimuth", QVariant.Double)]
            )
            compass.updateFields()
            for i, alpha in enumerate(range(round(aLeft), round(aRight))):
                c = QgsPoint(
                    xmin + (i*((xmax-xmin)/(aRight-aLeft))),
                    self.yMin-self.base.value())
                feature = QgsFeature()
                feature.setAttributes([alpha])
                feature.setGeometry(c)
                feats.append(feature)

            compass.dataProvider().addFeatures(feats)
            compass.commitChanges()

            QgsProject.instance().addMapLayer(compass)
            compass.loadNamedStyle(self.plugin_dir + "/compass.qml")

        # Line Slices --------------------------------------------------------------------
        if self.renderLines.isChecked():
            layer = QgsVectorLayer(
                "MultiLineString?crs={}".format(QgsProject.instance().crs().authid()),
                "Lines",
                "memory",
            )
            self.buildLayer(layer, aLines, progress)
            layer.loadNamedStyle(self.plugin_dir + "/lines.qml")

        # Poly Slices --------------------------------------------------------------------
        if self.renderPolygons.isChecked():
            pLayer = QgsVectorLayer(
                "Polygon?crs={}".format(QgsProject.instance().crs().authid()),
                "Polygons",
                "memory",
            )
            self.buildLayer(pLayer, aPolys, progress)
            if self.renderRidges.isChecked():
                pLayer.loadNamedStyle(self.plugin_dir + "/polygons_ridges.qml")
            else:
                pLayer.loadNamedStyle(self.plugin_dir + "/polygons.qml")

        # RIDGES --------------------------------------------------------------------
        if self.renderRidges.isChecked():
            hLayer = QgsVectorLayer(
                "LineString?crs={}".format(QgsProject.instance().crs().authid()),
                "Ridges",
                "memory",
            )
            hLayer.loadNamedStyle(self.plugin_dir + "/ridges.qml")
            QgsProject.instance().addMapLayer(hLayer)
            hLayer.startEditing()

            hLayer.dataProvider().addAttributes(
                [QgsField("demslicer_num", QVariant.Int)]
            )
            hLayer.dataProvider().addAttributes(
                [QgsField("demslicer_gaz", QVariant.Int)]
            )
            hLayer.dataProvider().addAttributes(
                [QgsField("demslicer_prof", QVariant.Int)]
            )
            hLayer.updateFields()

            horizons = []
            hiddens = []
            previousLine = None
            previousPolygon = None
            polyMax = None
            for lin, poly in zip(aLines[::-1], aPolys[::-1]):
                self.progressBar.setValue(progress)
                progress = progress + 1
                if previousLine is None:
                    previousLine = lin
                    previousPolygon = poly
                    continue

                if polyMax is not None and not polyMax.isNull():
                    cut = previousLine.difference(polyMax)
                    inter = previousLine.intersection(polyMax)
                    polyMax = polyMax.combine(previousPolygon)
                else:
                    cut = previousLine.difference(poly)
                    inter = previousLine.intersection(poly)
                    polyMax = previousPolygon

                horizons.append(cut)
                hiddens.append(inter)

                previousLine = lin
                previousPolygon = poly

            # last line
            cut = aLines[0].difference(aPolys[1])
            cut = cut.difference(polyMax)
            horizons.append(cut)

            fid = 1
            feats = []
            for prof, lin in enumerate(horizons):
                self.progressBar.setValue(progress)
                progress = progress + 1
                if lin.isMultipart():
                    try:
                        pp = lin.asMultiPolyline()
                        for polyline in pp:
                            if len(polyline) == 0:
                                continue
                            pt0 = polyline[0]
                            for pt in polyline[1:]:
                                seg = [pt0, pt]
                                feature = QgsFeature(fid)
                                feature.setAttributes(
                                    [str(fid), self.getGaz(pt0, pt, aPolys, prof), prof]
                                )
                                feature.setGeometry(QgsGeometry.fromPolylineXY(seg))
                                feats.append(feature)
                                fid = fid + 1
                                pt0 = pt
                    except Exception as e:
                        self.log("Err ds {} ligne {} ".format(inspect.stack()[0][3], inspect.currentframe().f_back.f_lineno))
                        self.log(e)
                else:
                    try:
                        if lin.isNull():
                            continue

                        polyline = lin.asPolyline()
                        if len(polyline) == 0:
                            continue

                        pt0 = polyline[0]
                        for pt in polyline[1:]:
                            seg = [pt0, pt]
                            feature = QgsFeature(fid)
                            feature.setAttributes(
                                [str(fid), self.getGaz(pt0, pt, aPolys, prof), prof]
                            )
                            feature.setGeometry(QgsGeometry.fromPolylineXY(seg))
                            feats.append(feature)
                            fid = fid + 1
                            pt0 = pt
                    except Exception as e:
                        self.log("Err ds {} ligne {} ".format(inspect.stack()[0][3], inspect.currentframe().f_back.f_lineno))
                        self.log(e)

            # lignes sous horizons
            for prof, lin in enumerate(hiddens):
                if lin.isMultipart():
                    try:
                        pp = lin.asMultiPolyline()
                        for polyline in pp:
                            if len(polyline) == 0:
                                continue

                            feature = QgsFeature(fid)
                            feature.setAttributes([str(fid), -1, prof])
                            feature.setGeometry(QgsGeometry.fromPolylineXY(polyline))
                            feats.append(feature)
                            fid = fid + 1
                    except Exception as e:
                        self.log("Err ds {} ligne {} ".format(inspect.stack()[0][3], inspect.currentframe().f_back.f_lineno))
                        self.log(e)
                else:
                    try:
                        if lin.isNull():
                            continue

                        polyline = lin.asPolyline()
                        if len(polyline) == 0:
                            continue

                        feature = QgsFeature(fid)
                        feature.setAttributes([str(fid), -1, prof])
                        feature.setGeometry(QgsGeometry.fromPolylineXY(polyline))
                        feats.append(feature)
                        fid = fid + 1
                    except Exception as e:
                        self.log("Err ds {} ligne {} ".format(inspect.stack()[0][3], inspect.currentframe().f_back.f_lineno))
                        self.log(e)

            hLayer.dataProvider().addFeatures(feats)
            hLayer.commitChanges()

        # POI --------------------------------------------------------------------
        aH, aD = self.mt.pY.azimuth(self.mt.pH), self.mt.pY.azimuth(self.mt.pD)
        if aD > aH:
            aH = aH + 360
        angleVue = 2 * (aH - aD)

        poiId = self.poiList.itemData(self.poiList.currentIndex())
        poiLayer = None
        if poiId != 0:
            poiLayer = QgsProject.instance().mapLayer(poiId)
            mapcrs = self.canvas.mapSettings().destinationCrs()
            xMap2Poi = QgsCoordinateTransform(
                mapcrs, poiLayer.crs(), QgsProject.instance()
            )
            xPoi2Map = QgsCoordinateTransform(
                poiLayer.crs(), mapcrs, QgsProject.instance()
            )

            # filter points (convex envelope)
            zon = self.mt.getLines()
            rq = QgsFeatureRequest().setFilterRect(
                xMap2Poi.transform(zon.boundingBox())
            )
            rq.setFlags(QgsFeatureRequest.ExactIntersect)
            features = poiLayer.getFeatures(rq)

            hull = zon.convexHull()
            if (
                poiLayer.wkbType() == QgsWkbTypes.Point
                or poiLayer.wkbType() == QgsWkbTypes.MultiPoint
            ):
                segAD = QgsGeometry.fromPolylineXY([self.mt.pA, self.mt.pD])
                feats = []
                fid = 1
                for feat in features:
                    poiPointXY = xPoi2Map.transform(
                        feat.geometry().asPoint().x(), feat.geometry().asPoint().y()
                    )
                    if hull.contains(poiPointXY):
                        z = self.getElevation(
                            self.xMap2Raster.transform(poiPointXY.x(), poiPointXY.y())
                        )
                        # reprojects points
                        azimuth = 0
                        if self.parallelView.isChecked():
                            depth = self.mt.d0 + self.mt.segCD.distance(
                                QgsGeometry.fromPointXY(poiPointXY)
                            )
                            newX = self.mt.pR.x() + segAD.distance(
                                QgsGeometry.fromPointXY(poiPointXY)
                            )
                        else:
                            depth = self.mt.pY.distance(poiPointXY)
                            azimuth = self.mt.pY.azimuth(poiPointXY)
                            az = azimuth + 360 if aD > azimuth else azimuth
                            fx = (az - aD) / angleVue
                            newX = self.mt.pR.x() + fx * self.mt.finalWidth

                        newZ = self.getNewZ(z, depth)
                        prof = self.getProf(depth)
                        newY = (
                            self.mt.pR.y()
                            + (newZ * self.zFactor.value())
                            + (depth * self.zShift.value() / self.mt.zoneDepth)
                        )

                        pt = QgsGeometry.fromPointXY(QgsPointXY(newX, newY))
                        visi = self.getVisibility(pt, aPolys, prof)
                        fet0 = QgsFeature(fid)
                        fet0.setAttributes(
                            feat.attributes()
                            + [str(fid), prof, z, depth, visi, azimuth]
                        )
                        fid = fid + 1
                        fet0.setGeometry(pt)
                        feats.append(fet0)

                if len(feats) > 0:
                    layer = QgsVectorLayer(
                        "MultiPoint?crs={}".format(
                            QgsProject.instance().crs().authid()
                        ),
                        "P.O.I.",
                        "memory",
                    )
                    QgsProject.instance().addMapLayer(layer)
                    layer.startEditing()
                    layer.dataProvider().addAttributes(
                        poiLayer.dataProvider().fields().toList()
                        + [
                            QgsField("demslicer_num", QVariant.Int),
                            QgsField("demslicer_prof", QVariant.Int),
                            QgsField("demslicer_z", QVariant.Int),
                            QgsField(
                                "demslicer_depth", QVariant.Double, "double", 4, 1
                            ),
                            QgsField("demslicer_visi", QVariant.Int),
                            QgsField(
                                "demslicer_azimuth", QVariant.Double, "double", 4, 1
                            ),
                        ]
                    )
                    layer.dataProvider().setEncoding(poiLayer.dataProvider().encoding())
                    layer.updateFields()

                    layer.dataProvider().addFeatures(feats)
                    layer.loadNamedStyle(self.plugin_dir + "/poi.qml")
                    layer.commitChanges()

            # Projeter des lignes ou polygones
            if (
                poiLayer.wkbType() == QgsWkbTypes.LineString
                or poiLayer.wkbType() == QgsWkbTypes.MultiLineString
            ):
                feats = []
                fid = 1
                for feat in features:
                    geom = QgsGeometry(feat.geometry())
                    geom.transform(xPoi2Map)
                    geom = geom.intersection(hull)
                    try:
                        geoms = [geom]
                        for _, cutingLine in enumerate(
                            self.mt.getLines().asMultiPolyline()
                        ):
                            newGeoms = []
                            for g in geoms:
                                _, rgeoms, _ = g.splitGeometry(cutingLine, True)
                                newGeoms = newGeoms + rgeoms

                            geoms = geoms + newGeoms

                        for geom in geoms:
                            try:
                                fet = projLineString(feat, geom.asPolyline())
                                if fet is not None:
                                    feats.append(fet)
                                    fid = fid + 1
                            except Exception:
                                collec = geom.asGeometryCollection()
                                for geom in collec:
                                    fet = projLineString(feat, geom.asPolyline())
                                    if fet is not None:
                                        feats.append(fet)
                                        fid = fid + 1
                    except Exception as e:
                        self.log("Err ds {} ligne {} ".format(inspect.stack()[0][3], inspect.currentframe().f_back.f_lineno))
                        self.log(e)

                if len(feats) > 0:
                    layer = QgsVectorLayer(
                        "MultiLineString?crs={}".format(
                            QgsProject.instance().crs().authid()
                        ),
                        "PROJ.",
                        "memory",
                    )
                    QgsProject.instance().addMapLayer(layer)
                    layer.startEditing()
                    layer.dataProvider().addAttributes(
                        poiLayer.dataProvider().fields().toList()
                        + [
                            QgsField("demslicer_num", QVariant.Int),
                            QgsField("demslicer_visi", QVariant.Int),
                            QgsField("demslicer_prof", QVariant.Int),
                        ]
                    )
                    layer.dataProvider().setEncoding(poiLayer.dataProvider().encoding())
                    layer.updateFields()

                    layer.dataProvider().addFeatures(feats)
                    layer.commitChanges()

            if (
                poiLayer.wkbType() == QgsWkbTypes.Polygon
                or poiLayer.wkbType() == QgsWkbTypes.MultiPolygon
            ):
                feats = []
                fid = 1
                for feat in features:
                    geom = QgsGeometry(feat.geometry())
                    geom.transform(xPoi2Map)
                    geom = geom.intersection(hull)
                    try:
                        geoms = [geom]
                        for _, cutingLine in enumerate(
                            self.mt.getLines().asMultiPolyline()
                        ):
                            newGeoms = []
                            for g in geoms:
                                _, rgeoms, _ = g.splitGeometry(cutingLine, True)
                                newGeoms = newGeoms + rgeoms

                            geoms = geoms + newGeoms

                        for geom in geoms:
                            try:
                                fet = projPolygon(feat, geom.asPolygon())
                                if fet is not None:
                                    feats.append(fet)
                                    fid = fid + 1
                            except Exception:
                                collec = geom.asGeometryCollection()
                                for geom in collec:
                                    fet = projPolygon(feat, geom.asPolygon())
                                    if fet is not None:
                                        feats.append(fet)
                                        fid = fid + 1
                    except Exception as e:
                        self.log("Err ds {} ligne {} ".format(inspect.stack()[0][3], inspect.currentframe().f_back.f_lineno))
                        self.log(e)

                if len(feats) > 0:
                    layer = QgsVectorLayer(
                        "Polygon?crs={}".format(QgsProject.instance().crs().authid()),
                        "PROJ.",
                        "memory",
                    )
                    QgsProject.instance().addMapLayer(layer)
                    layer.startEditing()
                    layer.dataProvider().addAttributes(
                        poiLayer.dataProvider().fields().toList()
                        + [
                            QgsField("demslicer_num", QVariant.Int),
                            QgsField("demslicer_visi", QVariant.Int),
                            QgsField("demslicer_prof", QVariant.Int),
                        ]
                    )
                    layer.dataProvider().setEncoding(poiLayer.dataProvider().encoding())
                    layer.updateFields()

                    layer.dataProvider().addFeatures(feats)
                    sourceStyles = poiLayer.styleManager().mapLayerStyles()
                    layer.styleManager().addStyle("poi", list(sourceStyles.values())[0])
                    layer.commitChanges()

    def build(self):
        """
        Build/Draw the final skylines
        """
        self.info("Build")
        self.buildSlices()

    def on_btnStart_toggled(self, checked):
        self.started = checked
        if checked:
            if self.start():
                self.btnStart.setText("Cancel")
            else:
                self.btnStart.toggle()
        else:
            self.btnStart.setText("Start")
            self.cancel()

    def on_lineCount_valueChanged(self, v):
        self.mt.updateRubberGeom()

    def on_zShift_valueChanged(self, v):
        self.mt.updateRubberGeom()

    def on_xStep_valueChanged(self, v):
        self.mt.updateRubberGeom()

    def on_base_valueChanged(self, v):
        self.mt.updateRubberGeom()

    def on_elevation_valueChanged(self, v):
        self.mt.updateRubberGeom()

    def on_zFactor_valueChanged(self, v):
        self.mt.updateRubberGeom()

    def on_parallelView_stateChanged(self, v):
        # self.elevation.setEnabled(not self.parallelView.isChecked())
        self.mt.updateRubberGeom()

    def on_btnBuild_released(self):
        self.build()

    def on_reset_released(self):
        self.mt.pX = None
        self.start()

    def on_rasterList_currentIndexChanged(self, i):
        id = self.rasterList.itemData(self.rasterList.currentIndex())
        self.mntLayer = QgsProject.instance().mapLayer(id)

        try:
            mapcrs = self.canvas.mapSettings().destinationCrs()
            self.xMap2Raster = QgsCoordinateTransform(
                mapcrs, self.mntLayer.crs(), QgsProject.instance()
            )
        except Exception:
            pass

    def on_btnSave_released(self):
        fileName, _ = QFileDialog.getSaveFileName(
            self, self.tr("Save parameters"), "", self.tr("Ini files (*.ini)")
        )
        if fileName:
            s = QSettings(fileName, QSettings.IniFormat)
            s.setValue("dem_slicer/Ax", self.mt.pA.x())
            s.setValue("dem_slicer/Ay", self.mt.pA.y())
            s.setValue("dem_slicer/Bx", self.mt.pB.x())
            s.setValue("dem_slicer/By", self.mt.pB.y())
            s.setValue("dem_slicer/Cx", self.mt.pC.x())
            s.setValue("dem_slicer/Cy", self.mt.pC.y())
            s.setValue("dem_slicer/Dx", self.mt.pD.x())
            s.setValue("dem_slicer/Dy", self.mt.pD.y())
            s.setValue("dem_slicer/Xx", self.mt.pX.x())
            s.setValue("dem_slicer/Xy", self.mt.pX.y())
            s.setValue("dem_slicer/Yx", self.mt.pY.x())
            s.setValue("dem_slicer/Yy", self.mt.pY.y())
            s.setValue("dem_slicer/Peakx", self.mt.pPeak.x())
            s.setValue("dem_slicer/Peaky", self.mt.pPeak.y())
            s.setValue("dem_slicer/Hx", self.mt.pH.x())
            s.setValue("dem_slicer/Hy", self.mt.pH.y())
            s.setValue("dem_slicer/Rx", self.mt.pR.x())
            s.setValue("dem_slicer/Ry", self.mt.pR.y())
            s.setValue("dem_slicer/Lx", self.mt.pL.x())
            s.setValue("dem_slicer/Ly", self.mt.pL.y())
            s.setValue("dem_slicer/rotation", self.mt.rotation)

            rId = self.rasterList.itemData(self.rasterList.currentIndex())
            s.setValue("dem_slicer/demLayerId", rId)
            poiId = self.poiList.itemData(self.poiList.currentIndex())
            s.setValue("dem_slicer/decoLayerId", poiId)
            s.setValue("dem_slicer/lineCount", self.lineCount.value())
            s.setValue("dem_slicer/elevation", self.elevation.value())
            s.setValue("dem_slicer/base", self.base.value())
            s.setValue(
                "dem_slicer/parallelView",
                "true" if self.parallelView.isChecked() else "false",
            )
            s.setValue("dem_slicer/xStep", self.xStep.value())
            s.setValue("dem_slicer/zShift", self.zShift.value())
            s.setValue("dem_slicer/zFactor", self.zFactor.value())
            s.setValue("dem_slicer/renderLines", self.renderLines.isChecked())
            s.setValue("dem_slicer/renderPolygons", self.renderPolygons.isChecked())
            s.setValue("dem_slicer/renderRidges", self.renderRidges.isChecked())

            s.sync()

    def on_btnLoad_released(self):
        fileName, _ = QFileDialog.getOpenFileName(
            self, self.tr("Load parameters"), "", self.tr("Ini files (*.ini)")
        )
        if fileName:
            s = QSettings(fileName, QSettings.IniFormat)
            self.mt.pA.setX(float(s.value("dem_slicer/Ax")))
            self.mt.pA.setY(float(s.value("dem_slicer/Ay")))
            self.mt.pB.setX(float(s.value("dem_slicer/Bx")))
            self.mt.pB.setY(float(s.value("dem_slicer/By")))
            self.mt.pC.setX(float(s.value("dem_slicer/Cx")))
            self.mt.pC.setY(float(s.value("dem_slicer/Cy")))
            self.mt.pD.setX(float(s.value("dem_slicer/Dx")))
            self.mt.pD.setY(float(s.value("dem_slicer/Dy")))
            self.mt.pX.setX(float(s.value("dem_slicer/Xx")))
            self.mt.pX.setY(float(s.value("dem_slicer/Xy")))
            self.mt.pY.setX(float(s.value("dem_slicer/Yx")))
            self.mt.pY.setY(float(s.value("dem_slicer/Yy")))
            self.mt.pPeak.setX(float(s.value("dem_slicer/Peakx")))
            self.mt.pPeak.setY(float(s.value("dem_slicer/Peaky")))
            self.mt.pH.setX(float(s.value("dem_slicer/Hx")))
            self.mt.pH.setY(float(s.value("dem_slicer/Hy")))
            self.mt.pR.setX(float(s.value("dem_slicer/Rx")))
            self.mt.pR.setY(float(s.value("dem_slicer/Ry")))
            self.mt.pL.setX(float(s.value("dem_slicer/Lx")))
            self.mt.pL.setY(float(s.value("dem_slicer/Ly")))
            self.mt.rotation = float(s.value("dem_slicer/rotation"))

            self.rasterList.setCurrentIndex(0)
            for i in range(self.rasterList.count()):
                if self.rasterList.itemData(i) == s.value("dem_slicer/demLayerId"):
                    self.rasterList.setCurrentIndex(i)

            self.poiList.setCurrentIndex(0)
            for i in range(self.poiList.count()):
                if self.poiList.itemData(i) == s.value("dem_slicer/decoLayerId"):
                    self.poiList.setCurrentIndex(i)

            self.lineCount.setValue(int(s.value("dem_slicer/lineCount")))
            try:
                self.elevation.setValue(int(s.value("dem_slicer/elevation")))
            except Exception:
                self.elevation.setValue(0)
            try:
                self.base.setValue(int(s.value("dem_slicer/base")))
            except Exception:
                self.base.setValue(0)

            self.parallelView.setChecked(s.value("dem_slicer/parallelView") == "true")
            self.xStep.setValue(float(s.value("dem_slicer/xStep")))
            self.zShift.setValue(float(s.value("dem_slicer/zShift")))
            self.zFactor.setValue(float(s.value("dem_slicer/zFactor")))
            self.renderLines.setChecked(
                True if s.value("dem_slicer/renderLines") else False
            )
            self.renderPolygons.setChecked(
                True if s.value("dem_slicer/renderPolygons") else False
            )
            self.renderRidges.setChecked(
                True if s.value("dem_slicer/renderRidges") else False
            )

            self.mt.rotation_init = self.mt.rotation
            self.mt.pA_init = QgsPointXY(self.mt.pA)
            self.mt.pB_init = QgsPointXY(self.mt.pB)
            self.mt.pC_init = QgsPointXY(self.mt.pC)
            self.mt.pD_init = QgsPointXY(self.mt.pD)
            self.mt.pX_init = QgsPointXY(self.mt.pX)
            self.mt.pY_init = QgsPointXY(self.mt.pY)
            self.mt.pPeak_init = QgsPointXY(self.mt.pPeak)
            self.mt.pH_init = QgsPointXY(self.mt.pH)
            self.mt.pL_init = QgsPointXY(self.mt.pL)
            self.mt.pR_init = QgsPointXY(self.mt.pR)

            self.mt.updateRubberGeom()

    def updateZ(self, pt):
        self.altY = self.getElevation(self.xMap2Raster.transform(pt))
        try:
            self.labelElevation.setText(
                "Obs. : {} m   +".format(
                    round(self.altY, int(2 - math.log10(self.altY)))
                )
            )
        except Exception:
            self.labelElevation.setText("Obs. : {} m   +".format(self.altY))


"""
Outils de manipulation de l'emprise et affichage d'un Ã©chantillon

        mode ortho             non ortho

     A------H-------B     .---A----H----B----Z
     |              |      \                /
     |  S   X       L       \   S  X       K
     |              |        \            /                  ~~~~~~~~~~~~~~~~
     D------M-------C         D----M----C        ->          ~~~~~~~~~~~~~~~~
     \      |      /           \   |   /                     R ~~~~~~~~~~~~~~
       \    d0   /              \ d0  /
         \  |  /                 \ | /
            Y                      Y

Les manipulations possibles :
- dÃ©placement de l'observateur (Y) [DC] reste constant, rotation autour de S (sommet)
- dÃ©placement de l'horizon AB (H) sur droite YH : M reste en place
- dÃ©placement 1er profil CD (M) sur droite YH: H reste en place
- Ã©largissement (L) largeur en mode ortho ou (K) angle
- rotation centre Y (B) ou (Z)

les poignÃ©es visibles : Y (obs), H, M, L, K, B, Z

"""
class Point():
    def __init__(self, pt=None):
        self.point = pt # QgsPointXY

    def setXY(self, x, y):
        self.point = QgsPointXY(x, y)

    def x(self):
        return self.point.x()

    def y(self):
        return self.point.y()

    def isOk(self):
        self.point is not None

    def distance(self, pt):
        return self.point.distance(pt.point)

    def azimuth(self, pt):
        return self.point.azimuth(pt.point)

# snap a point to a 2d line
# parameters:
#   A,B: the endpoints of the line
#   C: the point we want to snap to the line AB
# all parameters must be a tuple/list of float numbers
def snap_to_line(A,B,C):
    Ax,Ay = A.x(), A.y()
    Bx,By = B.x(), B.y()
    Cx,Cy = C.x(), B.y()

    eps = 0.0000001
    if abs(Ax-Bx) < eps and abs(Ay-By) < eps:
        return QgsPointXY(Ax,Ay)

    dx = Bx-Ax
    dy = By-Ay
    d2 = dx*dx + dy*dy
    t = ((Cx-Ax)*dx + (Cy-Ay)*dy) / d2
    if t <= 0: return QgsPointXY(Ax,Ay)
    if t >= 1: return QgsPointXY(Bx,By)
    return QgsPointXY(dx*t + Ax, dy*t + Ay)

class MapTool(QgsMapTool):
    MODE_NONE = 0
    MODE_PAN = 1
    MODE_ROTATE = 2
    MODE_SCALE = 3
    MODE_SCALE_X = 4
    MODE_SCALE_Y = 5
    MODE_PAN_RESULT = 6
    MODE_PEAK = 7

    MODE_Y_ROTATE = 10
    MODE_H_HORIZON = 11
    MODE_M_FIRST = 12
    MODE_L_LARG = 13
    MODE_K_ANGLE = 14
    MODE_B_ROTATE = 15
    MODE_Z_ROTATE = 16
    HANDLES = ('Y', 'H', 'M', 'L', 'K', 'B', 'Z', 'peak')
    HANDLES_1 = ('Y', 'H', 'M', 'L', 'B', 'peak')
    HANDLES_2 = ('Y', 'H', 'M', 'Z', 'K', 'peak')
    ALL_POINTS = ('X','A','B','C','D','L','Y','Z','K','M','R','peak','H','peakProj')

    def addRubber(self, typ, color=Qt.red, w=6):
        r = QgsRubberBand(self.canvas, typ)
        r.setStrokeColor(color)
        r.setWidth(w)
        self.rubbers.append(r)
        return r

    def __init__(self, widget):
        QgsMapTool.__init__(self, widget.canvas)
        self.widget = widget
        self.canvas = widget.canvas
        self.mode = self.MODE_NONE

        # clicked position
        self.p0 = None

        self.points = {}
        for p in self.ALL_POINTS:
            self.points[p] = Point()

        # rectangle vertices (handles)
        self.zoneWidth = None
        self.zoneDepth = None

        # Rubbers (Ã©lÃ©ments graphiques visibles) -----------
        self.rubbers = {}
        for p in ('thumbnail', 'horizon', 'box'):
            self.rubbers[p] = self.addRubber(QgsWkbTypes.PolygonGeometry)

        for p in  ('foc','lines'):
            self.rubbers[p] = self.addRubber(QgsWkbTypes.LineGeometry)

        for p in  ('peak', 'peakProj','B','H','L', 'Y', 'Z', 'K', 'M', 'R'):
            self.rubbers[p] = self.addRubber(QgsWkbTypes.PointGeometry)

        # Ordre de la dÃ©claration = ordre d'affichage

        # thumbnails skylines - profil Ã©chantillon projetÃ©
        self.rubber['thumbnail'].setStrokeColor(QColor(200, 120, 70, 130))
        self.rubber['thumbnail'].setWidth(0.8)
        # last line (blue)
        self.rubber['horizon'].setStrokeColor(QColor(70, 100, 255, 200))
        self.rubber['horizon'].setWidth(2)
        # peak projection
        self.rubber['peakProj'].setStrokeColor(QColor(255, 239, 15, 200))
        self.rubber['peakProj'].setWidth(4)
        # rectangle or cone
        self.rubber['box'].setStrokeColor(QColor(70, 100, 255, 200))
        self.rubber['box'].setWidth(3)
        # view angle
        self.rubber['foc'].setStrokeColor(Qt.blue)
        self.rubber['foc'].setWidth(1)
        # cutting lines
        self.rubber['lines'].setStrokeColor(QColor(40, 180, 30, 200))
        self.rubber['lines'].setWidth(1.5)
        # ROTATE node (eye)
        self.rubber['Y'].setStrokeColor(Qt.blue)
        # PEAK
        self.rubber['peak'].setStrokeColor(QColor(255, 239, 15, 200))

    def hide(self):
        for rb in self.rubbers:
            rb.reset()

    def updateRubberGeom(self):
        if not self.points['A'].isOk():
            return

        self.hide()

        # les poignÃ©es visibles : Y (obs), H, M, L ou K, B ou Z

        self.segCD = QgsGeometry.fromPolylineXY([self.points['C'], self.points['D']])
        self.segAD = QgsGeometry.fromPolylineXY([self.points['A'], self.points['D']])

        self.zoneWidth = self.points['A'].distance(self.points['B'])
        self.zoneDepth = self.points['A'].distance(self.points['D'])

        self.points['M'].setXY(
            (self.points['C'].x() + self.points['D'].x()) / 2, (self.points['C'].y() + self.points['D'].y()) / 2
        )
        self.d0 = self.points['M'].distance(self.points['Y'])
        self.horizon = self.points['H'].distance(self.points['Y'])
        self.widget.updateZ(self.points['Y'].point)

        self.rubber['foc'].setToGeometry(
            QgsGeometry.fromPolylineXY([self.pD, self.pY, self.pC])
        )

        if self.widget.parallelView.isChecked():
            self.rubber['box'].setToGeometry(
                QgsGeometry.fromPolygonXY([[self.points[p].point for p in ('D', 'A', 'B', 'C', 'D')]])
            )
            for p in self.HANDLES_1:
                self.rubber[p].setToGeometry(QgsGeometry.fromPointXY(self.points[p].point))
        else:
            for p in self.HANDLES_2:
                self.rubber[p].setToGeometry(QgsGeometry.fromPointXY(self.points[p].point))

        leftEdge = (
            QgsGeometry.fromPolylineXY([self.points[p].point for p in ('A', 'D')])
            .densifyByCount(self.widget.lineCount.value() - 2)
            .asPolyline()
        )
        rightEdge = (
            QgsGeometry.fromPolylineXY([self.points[p].point for p in ('B', 'C')])
            .densifyByCount(self.widget.lineCount.value() - 2)
            .asPolyline()
        )

        # cutting lines
        polylineX = []
        if self.widget.parallelView.isChecked():
            polyline = list(zip(leftEdge, rightEdge))

            backSide = (
                QgsGeometry.fromPolylineXY([self.points[p].point for p in ('A', 'B')])
                .densifyByDistance(self.widget.xStep.value())
                .asPolyline()
            )
            frontSide = (
                QgsGeometry.fromPolylineXY([self.points[p].point for p in ('D', 'C')])
                .densifyByDistance(self.widget.xStep.value())
                .asPolyline()
            )
            polylineX = list(zip(frontSide[:5], backSide[:5]))

            self.finalWidth = self.zoneWidth

        else:
            aH = self.points['Y'].azimuth(self.points['H'])
            aD = self.points['Y'].azimuth(self.points['D'])
            if aD > aH:
                aH = aH + 360

            alpha = aH - aD
            dAlphaDetail = 2 * alpha / (self.finalWidth / self.widget.xStep.value())
            dAlpha = 2 * alpha / 12

            aPrim = QgsGeometry.fromPointXY(self.points['H'].point)
            aPrim.rotate(-alpha, self.points['Y'].point)
            dPrim = QgsGeometry.fromPointXY(self.points['M'].point)
            leftEdge = (
                QgsGeometry.fromPolylineXY([aPrim.asPoint(), dPrim.asPoint()])
                .densifyByCount(self.widget.lineCount.value() - 2)
                .asPolyline()
            )
            polyline = []
            for p in leftEdge:
                line = []
                for nx in range(1 + 12):
                    g = QgsGeometry.fromPointXY(p)
                    g.rotate(nx * dAlpha, self.points['Y'].point)
                    line.append(g.asPoint())

                polyline.append(line)

            for _ in range(5):
                seg = QgsGeometry.fromPolylineXY(
                    [aPrim.asPoint(), dPrim.asPoint()]
                ).asPolyline()
                polylineX.append(seg)
                aPrim.rotate(dAlphaDetail, self.points['Y'].point)
                dPrim.rotate(dAlphaDetail, self.points['Y'].point)

            self.finalWidth = QgsGeometry.fromPolylineXY(
                polyline[int(len(polyline) / 2)]
            ).length()

        self.cuttingLines = polyline
        self.rubber['lines'].setToGeometry(
            QgsGeometry.fromMultiPolylineXY(
                polylineX
                + polyline[0:50]
                + polyline[:: max(1, 1 + int(len(polyline) / 50))][-50:]
            )
        )

        # final result
        self.rubber['peakProj'].setToGeometry(self.widget.getPeakGeom(self.points['peak']))

        polyline = []
        nbLines = self.widget.lineCount.value()
        for _ in range(nbLines)[::-1]:
            p1 = QgsPointXY(self.points['R'].x(), self.points['R'].y())
            p2 = QgsPointXY(self.points['R'].x() + self.finalWidth, self.points['R'].y())
            polyline.append([p1, p2])

        self.skyLines = polyline

        try:
            horizon, thumbnail = self.widget.getThumbnailGeom()
            self.rubber['thumbnail'].setToGeometry(thumbnail)
            self.rubber['horizon'].setToGeometry(horizon)
        except Exception as e:
            self.widget.log("Err ds {} ligne {} ".format(inspect.stack()[0][3], inspect.currentframe().f_back.f_lineno))
            self.widget.log(e)

        # alert
        nbPoints = int(len(polyline) * (self.finalWidth / self.widget.xStep.value()))
        alert = ""
        if nbPoints > 100000:
            alert = alert + "Attention : {} points\n".format(nbPoints)

        self.widget.alert.setText(alert)

    def getLines(self):
        return QgsGeometry.fromMultiPolylineXY(self.cuttingLines)

    def getSampleLines(self):
        return (
            [self.cuttingLines[0], self.cuttingLines[1]]
            + self.cuttingLines[2:-1][:: max(1, 1 + round((len(self.cuttingLines) - 3) / 9))]
            + [self.cuttingLines[-1]]
        )

    def getSkylines(self):
        return QgsGeometry.fromMultiPolylineXY(self.skyLines)

    def getSampleSkylines(self):
        return (
            [self.skyLines[0], self.skyLines[1]]
            + self.skyLines[2:-1][:: max(1, 1 + round((len(self.skyLines) - 3) / 9))]
            + [self.skyLines[-1]]
        )

    def newRubber(self):
        if self.points['X'].isOk():
            self.updateRubberGeom()
            return

        # default parameters
        h = 2 * self.widget.canvas.extent().height() / 3 / 20
        self.widget.xStep.setValue(round(h / 2, int(2 - math.log10(h / 2))))

        # first bbox, according to current view
        h = self.canvas.extent().height() / 6
        c = self.canvas.extent().center()
        rubberExtent = QgsRectangle(
            QgsPointXY(c.x() - h, c.y() - h), QgsPointXY(c.x() + h, c.y() + h)
        )
        self.rotation = 0.0
        width = rubberExtent.xMaximum() - rubberExtent.xMinimum()
        height = rubberExtent.yMaximum() - rubberExtent.yMinimum()

        # centre rectangle
        self.points['X'].setXY(
            rubberExtent.xMinimum() + width / 2, rubberExtent.yMinimum() + height / 2
        )

        self.points['A'].setXY(rubberExtent.xMinimum(), rubberExtent.yMaximum())
        self.points['B'].setXY(rubberExtent.xMaximum(), rubberExtent.yMaximum())
        self.points['C'].setXY(rubberExtent.xMaximum(), rubberExtent.yMinimum())
        self.points['D'].setXY(rubberExtent.xMinimum(), rubberExtent.yMinimum())
        self.segCD = QgsGeometry.fromPolylineXY([self.points['C'].point, self.points['D'].point])
        self.segAD = QgsGeometry.fromPolylineXY([self.points['A'].point, self.points['D'].point])

        # handles H / L
        self.points['H'].setX(
            (self.points['A'].x() + self.points['B'].x()) / 2, (self.points['A'].y() + self.points['B'].y()) / 2
        )
        self.points['L'].setXY(
            (self.points['B'].x() + self.points['C'].x()) / 2, (self.points['B'].y() + self.points['C'].y()) / 2
        )

        # eye (rotation)
        self.points['Y'].setXY(self.points['X'].x(), self.points['X'].y() - 2 * height / 3)

        # peak
        self.points['peak'].setXY((self.points['A'].x() + self.points['B'].x()) / 2, (self.points['B'].y() + self.points['C'].y()) / 2)

        self.points['M'].setXY(
            (self.points['C'].x() + self.points['D'].x()) / 2, (self.points['C'].y() + self.points['D'].y()) / 2
        )

        self.points['R'].setXY(self.points['D'].x() + width / 2, self.points['D'].y() + height / 2)

        # TODO
        self.points['K'].setXY(
            (self.points['B'].x() + self.points['C'].x()) / 2, (self.points['B'].y() + self.points['C'].y()) / 2
        )
        self.points['Z'].setXY(rubberExtent.xMaximum(), rubberExtent.yMaximum())

        self.rotation_init = self.rotation
        self.initpos = {}
        for p in self.ALL_POINTS:
            self.initpos[p] = QgsPointXY(self.points[p].point)

        self.updateRubberGeom()

    def canvasPressEvent(self, event):
        DIST = 5
        x = event.pos().x()
        y = event.pos().y()
        self.p0 = self.canvas.getCoordinateTransform().toMapCoordinates(x, y)

        self.mode == self.MODE_NONE
        for p in self.HANDLES:
            if self.p0.distance(self.points[p].point) / self.canvas.mapUnitsPerPixel() < DIST:
                self.mode = p
                return

        if self.rubber['box'].asGeometry().contains(self.p0):
            self.mode = 'box'
            return

    def move(self, pt, toMove, segOrPoint):
        if isinstance(segOrPoint, list):
            # cible projetÃ©e sur segment
            target = snap_to_line(self.initpos[segOrPoint[0]].point,self.initpos[segOrPoint[1]].point,pt)
        else:
            # point cible
            target = self.initpos[segOrPoint].point

        # position initiale du point Ã  dÃ©placer
        p1_init = self.initpos[toMove]
        # distance Ã  la cible (avant, aprÃ¨s)
        d_old = p1_init.distance(target)
        d_new = pt.distance(target)
        # ratio
        dd = min(max(d_new / d_old, 0.005), 10)

        dx = dd * (target.x(), p1_init.x())
        dy = dd * (target.y(), p1_init.y())
        return (dx, dy)

    def canvasMoveEvent(self, event):
        if self.mode == self.MODE_NONE:
            return

        x = event.pos().x()
        y = event.pos().y()
        pt = self.canvas.getCoordinateTransform().toMapCoordinates(x, y)
        dx = pt.x() - self.p0.x()
        dy = pt.y() - self.p0.y()

        # pan mode
        if self.mode == 'box':
            # dÃ©placer l'ensemble des points
            for p, p_ini in zip(self.points, self.initpos):
                p.setXY(p_ini.x() + dx, p_ini.y() + dy)

        # result pan
        if self.mode == 'R':
            # dÃ©placer seulement l'Ã©chantillon
            self.points[self.mode].setXY(self.initpos[self.mode].x() + dx, self.initpos[self.mode].y() + dy)

        # horizontal sizing
        if self.mode == 'L':
            toMove = self.points['L']
            # On dÃ©place L
            # distance L <-> [A,D]
            dx2, dy2 = self.move(pt, 'L', ['A', 'D'])
            toMove.setXY(toMove.x()+dx2, toMove.y() + dy2)

            # faire suivre A, B, D, C
            for p in ['B','C']:
                toMove = self.points[p]
                toMove.setXY(toMove.x()+dx2, toMove.y()+dy2)
            for p in ['A','D']:
                toMove = self.points[p]
                toMove.setXY(toMove.x()-dx2, toMove.y()-dy2)

        # horizon deplacement
        if self.mode == 'H':
            toMove = self.points['H']
            # On dÃ©place H
            # distance H <-> [C,D]
            dx2, dy2 = self.move(pt, 'H', ['C', 'D'])
            toMove.setXY(toMove.x()+dx, toMove.y() + dy2)

            # faire suivre A, B
            for p in ['A','B']:
                toMove = self.points[p]
                toMove.setXY(toMove.x()+dx2, toMove.y()+dy2)

        # first line deplacement
        if self.mode == 'M':
            toMove = self.points['M']
            # On dÃ©place M
            # distance M <-> [A,B]
            dx2, dy2 = self.move(pt, 'M', ['A', 'B'])
            toMove.setXY(toMove.x()+dx2, toMove.y() + dy2)

            # faire suivre C, D
            for p in ['C','D']:
                toMove = self.points[p]
                toMove.setXY(toMove.x()+dx2, toMove.y()+dy2)

        if self.mode == 'Y':
            self.points['Y'].setXY(self.initpos['Y'].x() + dx, self.initpos['Y'].y() + dy)

            azimuth = self.points['peak'].azimuth(pt)
            theta = azimuth - self.rotation_init + 180
            self.rotation = self.rotation_init + theta

            for p in ('A', 'B', 'C', 'D', 'H', 'L', 'M', 'K', 'Z'):
                A = QgsGeometry.fromPointXY(self.points[p])
                A.rotate(theta, self.points['peak'])
                self.points[p].setXY(A.asPoint().x(), A.asPoint().y())

        if self.mode == 'peak':
            self.points['peak'].setXY(self.initpos['peak'].x() + dx, self.initpos['peak'].y() + dy)

        self.updateRubberGeom()

    def canvasReleaseEvent(self, _):
        # rÃ©initialisation des positions initiales
        self.rotation_init = self.rotation
        for p in self.ALL_POINTS:
            self.initpos[p] = QgsPointXY(self.points[p].point)

        self.mode = self.MODE_NONE

    def activate(self):
        pass

    def deactivate(self):
        self.hide()

    def isZoomTool(self):
        return False

    def isTransient(self):
        return False

    def isEditTool(self):
        return True
